{"pages":[{"title":"关于","text":"除个别文章特殊声明外，均遵循 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议 感谢赞助 白羊李志远 联系方式 QQ:2424289243 Email: cairbin@aliyun.com Telegram: https://t.me/CairBin","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"友链","text":"Dalao 季悠然 —— 寻找有趣的灵魂 诺诺的魔法日记 —— 这是世界上最棒的诺诺的最棒的魔法日记 Rat’s Blog —— 何以解忧，唯有暴富 Bhao —— 世间无田螺，世间多田螺 三角猫 —— 挥舞双翅 追随阳光 寻找美好 Sonic853 —— Looking at the Stars. MoLeft‘s Blog —— 用心写好每一行php代码 Spoience的小栈 —— 一路寻访，不觉迷途 Link —— Just 4 Fun Snowneko —— 愿梦境般的白雪永不融化 MineCraft爱好者 —— 我的世界爱好者 邻居们 OkYes! 技术博客 —— 念念不忘，必有回响 白羊座の漫谈 —— 一些闲言碎语 摩尔の镇 | モル·町 —— 一个奇妙的小世界. 魔王のBlog —— 一个大学狗的博客 咕咕三原小窝 —— 记录美好，赠与未来 CC米饭 —— 也许是全新的世界！ 时雨 —— 千里之行，始於足下 渡鸦的小窝 —— 一条快乐咸鱼 ZigZagK的博客 —— Never give up fighting! 自由灵的梦境 —— 愿美梦成真 染念 小蓝家 —— 小蓝家Blog 栖枝perch —— 用心创造设计，改变生活 Rorical —— No Result ! Techoc’s blog —— 忆得旧时携手处，如今水远山长 Sakitami的集装箱 —— 我已经无敌了！ itsNekoDeng —— 十万伏特皮卡丘，梦想是世界和平，想要发光发热 Ealodi’s Blog —— 春山暖日和风，阑杆楼阁帘栊 小猫咪Blog —— 一个不起眼的小站 Drearry —— 仰望星空，遥望梦想 SurpriseLon’s blog —— あなたは主人公になりたいですか？ 申请友链须知 非商业网站 不涉及违法违规信息 请先按照下方信息添加本站 请不要未通知就将本站从友链移除 失效博客博主若未提前说明，请自博客失效起15天内恢复链接，否则本站将单方撤销友链 本站信息 名称：CairBin’s Blog 网址：https://cairbin.top 头像地址：https://cairbin.gitee.io/cair_img/img/bloglogo.png 描述：To be or not to be … 申请友链格式请留言告诉我你的： 1.网站名称： 2.网站地址： 3.头像地址： 4.网站简介： 提示 申请方式：评论区或发送邮箱（发送邮件更快些，我能直接看见） 我的电子邮箱地址以及其它联系方式在关于页面","link":"/friends/index.html"},{"title":"archives","text":"","link":"/archives/index.html"}],"posts":[{"title":"(更新)HTML+CSS制作一个高考倒计时","text":"2020-07-09更新 修复倒计时归零后出现负数的bug 自动切换至下一年日期 起因 最近听到要开学的消息，就会想到考试，提到考试自然就会想到受本次疫情影响的高考考生。最后琢磨着做一个高考倒计时网页。为了时间长一点，我特地把日期调为了2021年的高考(别问我，我也不知道我是怎么想的)。然后呢。。。我并不会html/css(因为学业繁忙，又一直以来专注学C语言)，于是就跟着B站制作新年倒计时网页的视频抄了抄代码~~ (图片都不换的那种) ~~，勉强搞出来了。 这里附上原地址：Bilibili 代码** html代码 ** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Countdown to NCEE&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;h2&gt;&lt;span&gt;Countdown to NCEE&lt;/span&gt; 2021&lt;/h2&gt; &lt;div class=&quot;countdown&quot;&gt; &lt;div id=&quot;day&quot;&gt;NA&lt;/div&gt; &lt;div id=&quot;hour&quot;&gt;NA&lt;/div&gt; &lt;div id=&quot;minute&quot;&gt;NA&lt;/div&gt; &lt;div id=&quot;second&quot;&gt;NA&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; function getEndTime(myYear){ var myEndTime = new Date(''+myYear+'/06/07 00:00:00'); return myEndTime; } function countDown(){ var mydate = new Date(); var year = '2021'; var EndTime = getEndTime(year); var NowTime = new Date(); if( (EndTime.getTime() - NowTime.getTime() ) &lt; 0){ year = mydate.getFullYear() + 1; EndTime = getEndTime(year); } var t = EndTime.getTime() - NowTime.getTime(); var d=Math.floor(t/1000/60/60/24); var h=Math.floor(t/1000/60/60%24); var m=Math.floor(t/1000/60%60); var s=Math.floor(t/1000%60); document.getElementById('day').innerText = d; document.getElementById('hour').innerText = h; document.getElementById('minute').innerText = m; document.getElementById('second').innerText = s; } setInterval(countDown,1000)&lt;/script&gt; ** CSS代码 ** 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586@import url(&quot;https://fonts.googleapis.com/css?family=Poppins:100,200,300,400,500,600,700,800,900&quot;);*{ margin: 0; padding: 0; font-family: 'Poppins', sans-serif;}body{ background: #000 url(bg.jpg); background-attachment: fixed; background-blend-mode: hard-light;}.container{ position: absolute; top: 80px; left: 100px; right: 100px; bottom: 80px; background: url(bg.jpg); background-attachment: fixed; display: flex; justify-content: center; align-items: center; flex-direction: column; box-shadow: 0 50px 50px rgba(0,0,0,0.5), 0 0 0 100px rgba(0,0,0,.1);}.container h2 { text-align: center; font-size: 10em; line-height: 0.7em; color: #333; margin-top: -80px;}.container h2 span{ display: block; font-weight: 300; letter-spacing: 6px; font-size: 0.2em;}.countdown{ display: flex; margin-top: 50px;}.countdown div{ position: relative; width: 100px; height: 100px; line-height: 100px; text-align: center; background: #333; color: #fff; margin: 0 15px; font-size: 3em; font-weight: 500;}.countdown div:before{ content: ''; position: absolute; bottom: -30px; left: 0; width: 100%; height: 35px; background: #ff0; color: #333; font-size: 0.35em; line-height: 35px; font-weight: 300;}.container #day:before{ content: 'Days';}.container #hour:before{ content: 'Hours';}.container #minute:before{ content: 'Minutes';}.container #second:before{ content: 'Seconds';} Git地址Gitee：https://gitee.com/cairbin/nceecountdown 项目演示地址：https://cairbin.gitee.io/nceecountdown/","link":"/2020/07/19/(%E6%9B%B4%E6%96%B0)HTML+CSS%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E9%AB%98%E8%80%83%E5%80%92%E8%AE%A1%E6%97%B6/"},{"title":"C Sharp 模拟高尔顿钉板正态分布","text":"起因数学学习了正态分布和高尔顿钉板模型，打算用C#模拟一下 展示 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using System;namespace ConsoleApp4{ class Program { static void Main(string[] args) { gal oa = new gal(); oa.infor(); Console.WriteLine(&quot;请输入格子数（正整数）：&quot;); string brid_input = Console.ReadLine(); Console.WriteLine(&quot;请输入小球数（正整数）：&quot;); string ball_input = Console.ReadLine(); uint brid_input2 = Convert.ToUInt32(brid_input); uint ball_input2 = Convert.ToUInt32(ball_input); oa.galton(brid_input2,ball_input2); Console.ReadLine(); } } class gal { public void infor() { Console.WriteLine(&quot;***********&quot;); Console.WriteLine(&quot; &quot;); Console.WriteLine(&quot; &quot;); Console.WriteLine(&quot; &quot;); Console.WriteLine(&quot;高尔顿钉板模型&quot;); Console.WriteLine(&quot; &quot;); Console.WriteLine(&quot; &quot;); Console.WriteLine(&quot; &quot;); Console.WriteLine(&quot;***********&quot;); Console.WriteLine(&quot; &quot;); } public void galton(uint Grid, uint Ball) { int[] grid = new int[Grid]; int number = 0; for (int counter_ball = 1; counter_ball &lt;= Ball; counter_ball++) { for(int times = 1; times &lt;= (Grid - 1); times++) { Random rd = new Random(); double l = rd.NextDouble()*2; int rand = (int)l; number += rand; } grid[number]++; number = 0; } Console.WriteLine(&quot;小球总数为{0},格数为{1}&quot;, Ball, Grid); for (int index = 0;index &lt; grid.Length; index++) { int k = index + 1; Console.WriteLine(&quot;{0}号格子小球数为{1}&quot;, k, grid[index]); } } }} GitGitHub:https://github.com/CairBin/GaltonKnockedBoards","link":"/2020/04/17/C%20Sharp%20%E6%A8%A1%E6%8B%9F%E9%AB%98%E5%B0%94%E9%A1%BF%E9%92%89%E6%9D%BF%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83/"},{"title":"C++ 输出斐波那契数列","text":"代码先贴代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int main(){ int n = 1; double n_m = 93; cout &lt;&lt; endl; while(1){ int n = 1; long long int a=1; long long int b=1; cout &lt;&lt; &quot;Please input the max value of n.&quot; &lt;&lt; endl; cin &gt;&gt; n_m; int n_max = static_cast&lt;int&gt; (n_m); if (n_max &lt; 1){ cout &lt;&lt; &quot;The max value of n is error.&quot; &lt;&lt; endl; } if (n_max &gt; 92){ //因为斐波那契数列发散很快，所以给n一个上限，防止数列数值溢出 cout &lt;&lt; &quot;The value is too large.&quot; &lt;&lt; endl; } else{ while(n &lt;= n_max){ if (n == 1){ cout &lt;&lt; a &lt;&lt; endl; n++; } if ( n== 2){ cout &lt;&lt; b &lt;&lt; endl; n++; } else{ a = a+b; cout &lt;&lt; a &lt;&lt; endl; n++; b = a+b; cout &lt;&lt; b &lt;&lt; endl; n++; } } } }} 复制 相关知识斐波那契数列递推关系F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）通项公式 为便于理解，本文章方法是根据递推关系来写的程序相关数学知识请参考：百度百科","link":"/2020/03/03/C++-%E8%BE%93%E5%87%BA%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"title":"C Sharp 数据类型","text":"值类型整数类型用途：整数类型用来存储整数值。 表示形式： 十进制(不能以0开头，0除外) 八进制(必须以0开头) 十六进制(必须以0X或0x开头) 类型 说明 范围sbyte 8位有符号整数 -128127short 16位有符号整数 -3276832767int 32位有符号整数 -21474836482147483647long 64位有符号整数 -92233720368547758089223372036854775807byte 8位无符号整数 0255ushort 16位无符号整数 065535uint 32位无符号整数 04294967295ulong 64位无符号整数 018446744073709551615 浮点类型用途：主要用于处理含有小数数值的数据。 类型 说明 范围float 精确到7位数 +-1.510^(-45) ~ +-3.4×10^38double 精确到15~16位数 +-5.010^(-324) ~ +-1.7×10^308 布尔类型用途：主要用来表示true/false值 类型 说明bool true/false 引用类型堆的概念：堆是一中由系统弹性配置的内存空间，没有特定大小及存活时间，因此可以被弹性地运用于对象访问。 特征： 必须在托管堆中为引用类型变量分配内存 使用new关键字来创建引用类型变量 在托管堆中分配的每个对象都有与之相关联的附加成员，这些成员必须被初始化 引用类型变量是由垃圾回收机制来管理的 多个引用类型变量可以引用同一对象，在这种情形下，对一个变量的操作会影响另外一个变量所引用的同一对象 引用类型被赋值前的值都是null 实例如下： 123456789101112131415161718192021using System;class Program{ class C //创建一个类C { public int Value = 0; //声明一个公共int类型的变量Value } static void Main(string[] args) { int v1 = 0; int v2 =v1; v2 = 927; C r1 = new C(); //使用new关键字创建引用对象 C r2 = r1; r2.Value = 112; Console.WriteLine(&quot;Values:{0},{1}&quot;,v1,v2); //输出 v1 v2 变量 Console.WriteLine(&quot;Refs:{0},{1}&quot;,r1.Value,r2.Value); //输出引用类型对象的Value Console.ReadLine(); }} ** 输出结果 ** 12Values:0,927Refs:112,112","link":"/2020/04/11/C%20Sharp%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"C++ 限定符Const和指针","text":"指向常量的指针指向常量的指针不能用于其所指对象的值。若想存放常量对象的地址，只能使用指向常量的指针。 1234const int a = 3; //a是个常量，其值不能改变int *b = &amp;a; //错误：b是个普通指针const int *c = &amp;a; //正确*c = 8; //错误：c不能给a赋值 允许一个指向常量的指针指向一个非常量，但不能通过该指针修改这个非常量的值（但该非常量可以通过其他途径修改）。 12int d = 0; //一个整型变量c = &amp;d; //正确，但不能通过指针c修改d的值 const指针常量指针必须初始化，而且一旦初始化完成其值（也就是放在指针的那个地址）就不能改变了。把*放在const前说明不变的是指针的值而不是所指的那个值。 123456789int a = 0;int b = 1;const int *c = &amp;a;int *const d = &amp;a;c = &amp;b; //正确：但不能通过c改变b的值*d = 5; //正确：可以通过d改变a的值d = &amp;b; //错误：d是一个常量指针，其本身的值不能改变 顶层const与底层const基本概念指针本身是不是常量与指针所指对象是不是常量是两个相互独立的问题。用名词 顶层 const 表示本身是个常量。用名词 底层 const 表示所指对象是个常量。 一般的，顶层const可以表示任意的对象。底层cosnt则与指针和引用等复合类型的基本类型有关。 特殊的，指针可以同时是顶层const和底层const;声明引用的const都是底层cosnt。 1234int a = 0;int *const p1 = &amp;i; //顶层constconst int b = 42; //顶层constconst int *p2 = &amp;b; //底层const 拷贝操作 顶层const在进行拷贝操作时不受什么影响12const int a = 0;int b = a; //正确：二者类型相同且顶层const不受影响 底层const的限制不能忽视！拷入和烤出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说非常量能转换成常量，反之则不行。1234567891011const int a = 0;const int *const p = &amp;a; //具有顶层和底层const的指针p,靠右边的是顶层，靠左边的是底层const int &amp;b = a; //声明引用的const都是底层constint b = a; //正确：a包含顶层const，无影响int *p1 = p; //错误：p包含底层const，p1没有const int *p2 = p; //正确：二者都包含底层const，p的顶层const无影响int i = 1;p2 = &amp;i; //正确：int*能转换成const int*","link":"/2020/08/27/C++-%E9%99%90%E5%AE%9A%E7%AC%A6Const%E5%92%8C%E6%8C%87%E9%92%88/"},{"title":"C++五子棋(三)——判断鼠标有效点击","text":"分析在鼠标左键点击时，我们不能让新棋子在已有棋子的位置落下，同时我们还要让棋子在规定位置落下——棋盘线的交点处。 功能实现创建数据类型 创建头文件chessData.h和源文件chessData.cpp 在chessData.cpp和main.cpp中分别引用头文件chessData.h 1#include &quot;chessData.h&quot; 将之前在main.cpp中写的棋盘数据剪贴到chessData.h中 12const float BLOCKSIZE = 67.4;const int BLOCK_GRAD_SIZE = 13; 在chessData.h中定义常量 POS_OFFSET，即鼠标有效点击距离上限 1const int POS_OFFSET = BLOCKSIZE * 0.4; 在chessData.h定义结构体 ChessData 123456789struct ChessData{ //储存当前游戏棋盘的情况，空白为0，黑棋为1，白棋为-1 int chessMap[BLOCK_GRAD_SIZE][BLOCK_GRAD_SIZE]; //储存各点的评分情况，用于之后的AI走棋 int scoreMap[BLOCK_GRAD_SIZE][BLOCK_GRAD_SIZE]; bool playFlag; //表示下棋放，true黑棋，false白棋（AI） }; 在main.cpp中添加全局变量game 1ChessData game; 初始化数据类型 在chessData.h中添加函数声明 1void initChessData(ChessData*); 在chessData.cpp 1234567void initChessData(ChessData *data){ if(!data) return; memset(data-&gt;chessMap,0,sizeof(data-&gt;chessMap)); memset(data-&gt;scoreMap,0,sizeof(data-&gt;scoreMap)); data-&gt;playFlag = true; } 判断有效点击算法原理 实现 在main.cpp中添加全局变量 1int clickPosRow, clickPosCol; //用于储存点击位置 定义函数clickBoard() 1234567891011121314151617//有效点击返回true，无效点击返回false//MOUSEMSG为鼠标信息类型bool clickBoard(MOUSEMSG msg){ //（鼠标点击坐标 - 边界长度）/ 格宽 = 行（列）数 //计算列数并取整 int col = (msg.x - MARGIN_X) / BLOCKSIZE; //计算行数取整 int row = (msg.y - MARGIN_Y) / BLOCKSIZE; //计算棋子正确坐标，即格子左上角棋子应在的棋盘格线交点处坐标 int leftTopPosX = MARGIN_X + BLOCKSIZE * col; int leftTopPosY = MARGIN_Y + BLOCKSIZE * row; } 在文件最上方引用头文件math.h用于后期计算 1#include &lt;math.h&gt; 之后要判断棋子应在四个交点中具体哪一点上，这里我们用一个do-while循环。继续添加**clickBoard()**函数的定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int len; //用于计算两点见的距离（根据中学所学两点间距离公式）int selectPos = false; //作为返回值do{ //左上角 len = sqrt((msg.x - leftTopPosX)*(msg.x - leftTopPosX) + (y - leftTopPosY)*(msg.y - leftTopPosY)); if(len &lt; POS_OFFSET){ clickPosRow = row; clickPosCol = col; if ( game.chessMap[clickPosRow][clickPosCol] == 0 ){ selectPos = true; } break; } //右上角 len = sqrt((msg.x - leftTopPosX - BLOCKSIZE)*(msg.x - leftTopPosX - BLOCKSIZE) + (y - leftTopPosY)*(msg.y - leftTopPosY)); if(len &lt; POS_OFFSET){ clickPosRow = row; clickPosCol = col + 1; if ( game.chessMap[clickPosRow][clickPosCol] == 0 ){ selectPos = true; } break; } //左下角 len = sqrt((msg.x - leftTopPosX)*(msg.x - leftTopPosX) + (y - leftTopPosY - BLOCKSIZE)*(msg.y - leftTopPosY - BLOCKSIZE)); if(len &lt; POS_OFFSET){ clickPosRow = row + 1; clickPosCol = col; if ( game.chessMap[clickPosRow][clickPosCol] == 0 ){ selectPos = true; } break; } //右下角 len = sqrt((msg.x - leftTopPosX - BLOCKSIZE)*(msg.x - leftTopPosX - BLOCKSIZE) + (y - leftTopPosY - BLOCKSIZE)*(msg.y - leftTopPosY - BLOCKSIZE)); if(len &lt; POS_OFFSET){ clickPosRow = row + 1; clickPosCol = col + 1; if ( game.chessMap[clickPosRow][clickPosCol] == 0 ){ selectPos = true; } break; } }while(0);return selectPos; 更新底层数据 chessData.h 1void updateGameMap(ChessData* data, int row, int col); chessData.cpp 123456789101112void updateGameMap(ChessData* data, int row, int col){ if(!data) return; if(data-&gt;playFlag){ data-&gt;chessMap[row][col] = 1; }else{ data-&gt;chessMap[row][col] = -1; } data-&gt;playFlag = !data-&gt;playFlag; //换下棋方 } main.cpp 123456//玩家走棋void manGo(){ chessDown(clickPosRow,clickPosCol,CHESS_BLACK); updateGameMap(&amp;game, clickPosRow, clickPosCol); }","link":"/2021/06/30/C++%E4%BA%94%E5%AD%90%E6%A3%8B(%E4%B8%89)%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E9%BC%A0%E6%A0%87%E6%9C%89%E6%95%88%E7%82%B9/"},{"title":"C++五子棋(五)——实现AI落子","text":"AI思考落子点在之前我们已经实现计算权值了，现在要想让AI落子，应根据之前的计算结果使棋子落在分值最大点上。当然可能会出现多个分值相同的最大点，这时在其中随机取一个点落下即可。 chessData.h 1234567typedef struct point{ int row; int col;} point_t;//机器下棋point_t actionAI(ChessData* data); chessData.cpp 123#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;vector&gt; 12345678910111213141516171819202122232425262728293031323334353637point_t actionAI(ChessData* data){ //计算评分 calcScore(data); //找出最大分数位置 int maxScore = 0; std::vector&lt;std::pair&lt;int, int&gt;&gt; maxPoints; int k = 0; for(int row = 0; row &lt; BOARD_GRAD_SIZE; row++){ for(int col = 0; col &lt; BOARD_GRAD_SIZE; col++){ //若该坐标为空 if(data-&gt;chessMap[row][col] == 0){ //找出最大数和坐标 if(data-&gt;scoreMap[row][col] &gt; maxScore){ maxScore.clear(); k = 0; maxScore.push_back(std::make_pair(row, col)); k++; }else if(data-&gt;scoreMap[row][col] == maxScore){ maxPoints.push_back(std::make_pair(row, col)); k++; } } } } //如果有多个点随机落子 srand((unsigned)time(0)); int index = rend() % k; return maxPoints[index]; } 实现AI落子 main.cpp 12345678910void AI_GO(){ point_t point = actionAI(&amp;game); clickPosRow = point.row; clickPosCol = point.col; Sleep(1000); chessDown(clickPosRow, clickPosCol, CHESS_WHITE); updateGameMap(&amp;game, clickPosRow, clickPosCol); }","link":"/2021/07/14/C++%E4%BA%94%E5%AD%90%E6%A3%8B(%E4%BA%94)%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0AI%E8%90%BD%E5%AD%90/"},{"title":"C++五子棋(七)——main函数以及项目总结","text":"main函数 main.cpp 代码如下123456789101112131415161718192021222324252627int main(void){ init(); while(1){ //一直检测鼠标点击 MOUSEMSG msg == GetMouseMsg(); if(msg.uMsg == WM_LBUTTONDOWN){ manGo(); if(checkOver()){ init(); continue; } AI_GO(); if(checkOver()){ init(); continue; } } } closegraph(); return 0; } 项目总结 学习了c语言模块化开发 设计了判断鼠标点击的算法 掌握了AI走棋的写法 …… 不足之处 代码缺乏优化，vector没有充分使用 玩家不能选择棋子颜色 无法进行玩家对战 AI算法效率不够高 进阶 继续学习数据结构与算法对AI进行优化 尝试建立服务器实现网络对战等","link":"/2021/07/15/C++%E4%BA%94%E5%AD%90%E6%A3%8B(%E4%B8%83)%E2%80%94%E2%80%94main%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"title":"C++五子棋(一)——开发环境","text":"开发环境环境准备 Visual Studio Windows EasyX图形库 素材文件素材文件已经准备了，点击此处获取 百度网盘链接提取码：su6p 创建项目 打开Visual Studio 创建空项目 创建源文件main.cpp 在项目属性中的“高级”一栏里，设置使用多字节字符集 导入资源(解压后的文件夹改名为res) 结束环境搭建就说这些，不会的自行百度，接下来就要开始开发五子棋了","link":"/2021/06/30/C++%E4%BA%94%E5%AD%90%E6%A3%8B(%E4%B8%80)%E2%80%94%E2%80%94%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"C++五子棋(六)——游戏结束","text":"规则原理如图 判断游戏结束 chessData.h 12//row,col 表示当前落子bool checkWin(ChessData* game, int row, int col); 横、竖、斜（斜有两种）共四种情况，每种情况根据当前落子往后遍历5个子，有一种符合就胜利 chessData.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748bool checkWin(ChessData* game, int row, int col){ //横 for(int i = 0; i &lt; 5; i++){ if(col - i &gt;= 0 &amp;&amp; col - i + 4 &lt; BOARD_GRAD_SIZE &amp;&amp; game-&gt;chessMap[row][col-i] == game-&gt;chessMap[row][col-i+1] &amp;&amp; game-&gt;chessMap[row][col-i] == game-&gt;chessMap[row][col-i+2] &amp;&amp; game-&gt;chessMap[row][col-i] == game-&gt;chessMap[row][col-i+3] &amp;&amp; game-&gt;chessMap[row][col-i] == game-&gt;chessMap[row][col-i+4]){return true;} } //竖 for(int i = 0; i &lt; 5; i++){ if(row - i &gt;= 0 &amp;&amp; row - i + 4 &lt; BOARD_GRAD_SIZE &amp;&amp; game-&gt;chessMap[row-i][col] == game-&gt;chessMap[row-i+1][col] &amp;&amp; game-&gt;chessMap[row-i][col] == game-&gt;chessMap[row-i+2][col] &amp;&amp; game-&gt;chessMap[row-i][col] == game-&gt;chessMap[row-i+3][col] &amp;&amp; game-&gt;chessMap[row-i][col] == game-&gt;chessMap[row-i+4][col]){return true;} } // “/”方向 for(int i = 0; i &lt; 5; i++){ if(row + i &lt; BOARD_GRAD_SIZE &amp;&amp; row + i - 4 &gt;= 0 &amp;&amp; col - i &gt;= 0 &amp;&amp; col - i + 4 &lt; BOARD_GRAD_SIZE &amp;&amp; game-&gt;chessMap[row+i][col-i] == game-&gt;chessMap[row+i-1][col-i+1] &amp;&amp; game-&gt;chessMap[row+i][col-i] == game-&gt;chessMap[row+i-2][col-i+2] &amp;&amp; game-&gt;chessMap[row+i][col-i] == game-&gt;chessMap[row+i-3][col-i+3] &amp;&amp; game-&gt;chessMap[row+i][col-i] == game-&gt;chessMap[row+i-4][col-i+4]){return true;} } // “\\”方向 for(int i = 0; i &lt; 5; i++){ if(row - i &gt;= 0 &amp;&amp; row - i - 4 &lt; BOARD_GRAD_SIZE &amp;&amp; col - i &gt;= 0 &amp;&amp; col - i + 4 &lt; BOARD_GRAD_SIZE &amp;&amp; game-&gt;chessMap[row-i][col-i] == game-&gt;chessMap[row-i+1][col-i+1] &amp;&amp; game-&gt;chessMap[row-i][col-i] == game-&gt;chessMap[row-i+2][col-i+2] &amp;&amp; game-&gt;chessMap[row-i][col-i] == game-&gt;chessMap[row-i+3][col-i+3] &amp;&amp; game-&gt;chessMap[row-i][col-i] == game-&gt;chessMap[row-i+4][col-i+4]){return true;} } return false; } 调用接口 main.cpp 1#include &lt;stdio.h&gt; 12345678910111213141516171819202122232425262728293031323334bool checkOver(){ if(checkWin(&amp;game, clickPosRow, clickPosCol)){ Sleep(1500); if(game.playFlag = false){ //黑棋胜利，此时标记已经转为白棋落子 mciSendString(&quot;play res/不错.mp3&quot;, 0, 0, 0); loadimage(0, &quot;res/胜利.jpg&quot;); score += 100; //更新分数 }else{ mciSendString(&quot;play res/失败.mp3&quot;, 0, 0, 0); loadimage(0, &quot;res/失败.jpg&quot;); score -= 100; //同理 } //用于显示分数 char scoreText[64]; sprintf(scoreText, &quot;当前分数：%d&quot;, score); outtextxy(310, 800, scoreText); //记录分数 FILE* fp = fopen(&quot;score.data&quot;, &quot;wb&quot;); fwrite(&amp;score, sizeof(score), 1, fp); fclose(fp); getch(); return true; } return false; } 显示分数 main.cpp 12#define INIT_SCORE 1000int score; //全局变量 1234567891011121314void initScore(){ //分数字体设置 settextcolor(WHITE); //color settextstyle(50, 0, &quot;微软雅黑&quot;); //style FILE *fp = fopen(&quot;score.data&quot;, &quot;rb&quot;); if(fp == NULL){ score = INIT_SCORE; }else{ fread(&amp;score, sizeof(score), 1, fp); } if (fp)fclose(fp); } 然后在main.cpp文件的 init() 函数定义中 继续 添加代码 1initScore(); //这一行添加到init()函数定义中 结束到这里五子棋的全部功能已经实现了，但是你会发现程序无法运行。这是理所当然的，因为我们的main函数还没有写，在下一篇文章（也就是本项目的最后一章）我们将完善main函数并做该项目的总结。","link":"/2021/07/15/C++%E4%BA%94%E5%AD%90%E6%A3%8B(%E5%85%AD)%E2%80%94%E2%80%94%E6%B8%B8%E6%88%8F%E7%BB%93%E6%9D%9F/"},{"title":"C++五子棋(四)——走棋原理及权值计算","text":"原理计算 计算每个落子点的“权值”，找到权值最大的落子点 对于每个空白点，分别计算周围的八个方向 不妨以该空白点作为参照原点，以水平向右作为X轴正方向，以竖直向下为Y轴正方向建立平面直角坐标系 因为在计算某个方向时，正向和反向需同时考虑，实际上只需要四个方向，即向量(1,0)的方向、向量(1,1)方向、向量(0,1)方向和向量(-1,1)方向，图示如下(灵魂画图，请勿吐槽 滑稽) 走棋原理 产生效果 黑棋走这个点 产生效果 评分 连2 10 死3 30 活3 40 死4 60 活4 200 连5 20000 如果白棋（AI）走这个点 产生效果 评分 连1 5 连2 10 死3 25 活3 50 死4 55 活4 300 连5 30000 权值计算 chessData.h 1void calcScore(ChessData* data); chessData.cpp 1#include &lt;string&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151void calcScore(ChessData* data){ if(!data) return; //统计玩家或AI连子 int personNum = 0; //玩家 int botNum = 0; //AI int emptyNum = 0; //各方向空白位数 //清空评分数组 memset(data-&gt;scoreMap, 0, sizeof(data-&gt;scoreMap)); for (int row = 0; row &lt; BOARD_GRAD_SIZE; row++){ for(int col = 0; col &lt; BOARD_GRAD_SIZE; col++){ //空白点计算 if(row &gt;= 0 &amp;&amp; col &gt;= 0 &amp;&amp; data-&gt;chessMap[row][col] == 0){ //遍历四个方向，然后分别计算正反四个方向 int directs[4][2] = {{1,0}, {1,1}, {0,1}, {-1,1}}; for(int k = 0; k &lt; 4; k++){ int x = directs[k][0]; int y = directs[k][1]; //重置 personNum = 0; botNum = 0; emptyNum = 0; //对黑棋评分(正向) for(int i = 1; i &lt;= 4; i++){ if(row + i * y &gt;= 0 &amp;&amp; row + i * y &lt; BOARD_GRAD_SIZE &amp;&amp; col + i * x &gt;= 0 &amp;&amp; col + i * x &lt; BOARD_GRAD_SIZE &amp;&amp; data-&gt;chessMap[row + i * y][col + i * x] == 1){ //玩家的子 personNum++; }else if(row + i * y &gt;= 0 &amp;&amp; row + i * y &lt; BOARD_GRAD_SIZE &amp;&amp; col + i * x &gt;= 0 &amp;&amp; col + i * x &lt; BOARD_GRAD_SIZE &amp;&amp; data-&gt;chessMap[row + i * y][col + i * x] == 0){ //空白位 emptyNum++; break; //遇到空白位置停止该方向搜索 }else{ break; //出边界或遇到白棋停止搜索 } } //对黑棋评分(反向) for(int i = 1; i&lt;= 4; i++){ if(row - i * y &gt;= 0 &amp;&amp; row - i * y &lt; BOARD_GRAD_SIZE &amp;&amp; col - i * x &gt;= 0 &amp;&amp; col - i * x &lt;BOARD_GRAD_SIZE &amp;&amp; data-&gt;chessMap[row - i * y][col - i * x] == 1){ personNum++; }else if(row - i * y &gt;= 0 &amp;&amp; row - i * y &lt;BOARD_GRAD_SIZE &amp;&amp; col - i * x &gt;= 0 &amp;&amp; col - i * x &lt; BOARD_GRAD_SIZE &amp;&amp; data-&gt;chessMap[row -i * y][col - i * x] == 0){ emptyNum++; break; }else{ break; } } if(personNum == 1){ data-&gt;scoreMap[row][col] += 10; }else if(personNum == 2){ if(emptyNum == 1){ //死3 data-&gt;scoreMap[row][col] += 30; }else if(emptyNum == 2){ //活3 data-&gt;scoreMap[row][col] += 40; } }else if(personNum == 3){ if(empty == 1){ //死4 data-&gt;scoreMap[row][col] += 60; }else if (emptyNum == 2){ //活4 data-&gt;scoreMap[row][col] += 200; } }else if(personNum == 4){ data-&gt;scoreMap[row][col] += 20000; } emptyNum = 0; //清空 //对白棋评分（正向） for(int i = 1; i &lt;= 4; i++){ if(row + i * y &gt; 0 &amp;&amp; row + i * y &lt; BOARD_GRAD_SIZE &amp;&amp; col + i * x &gt; 0 &amp;&amp; col + i * x &lt; BOARD_GARD_SIZE &amp;&amp; data-&gt;chessMap[row + i * y][col + i * x == -1]){ botNum++; }else if(row + i * y &gt;0 &amp;&amp; row + i * y &lt; BOARD_GRAD_SIZE &amp;&amp; col + i * x &gt; 0 &amp;&amp; col + i * x &lt; BOARD_GRAD_SIZE &amp;&amp; data-&gt;chessMap[row + i * y][col + i *x] == 0){ emptyNum++; break; }else{ break; } } //白棋评分(反向) for(int i = 1; i &lt;= 4; i++){ if(row - i * y &gt; 0 &amp;&amp; row - i * y &lt;BOARD_GRAD_SIZE &amp;&amp; col - i * x &gt; 0 &amp;&amp; col - i * x &lt; BOARD_GRAD_SIZE &amp;&amp; data-&gt;chessMap[row - i * y][col -i * x] == -1){ botNum++; }else if (row - i * y &gt;0 &amp;&amp; row - i * y &lt; BOARD_GRAD_SIZE &amp;&amp; col - i * x &gt; 0 &amp;&amp; col - i * x &lt; BOARD_GRAD_SIZE &amp;&amp; data-&gt;chessMap[row - i * y][col - i * x] == 0){ emptyNum++; break; }else{ break; //出边界 } } if(botNum == 0){ //连1 data-&gt;scoreMap[row][col] += 5; }else if(botNum == 1){ //活2 data-&gt;scoreMap[row][col] += 10; }else if(botNum == 2){ if(emptyNum == 1){ //死3 data-&gt;scoreMap[row][col] += 25; }else if(emptyNum == 2){ //活3 data-&gt;scoreMap[row][col] += 50; } }else if(botNum == 3){ if(emptyNum == 1){ //死4 data-&gt;scoreMap[row][col] += 55; }else if(botNum == 2){ //活4 data-&gt;scoreMap[row][col] += 300; } }else if(botNum &gt;= 4){ //活5 data-&gt;scoreMap[row][col] += 30000; } } } } }}","link":"/2021/07/07/C++%E4%BA%94%E5%AD%90%E6%A3%8B(%E5%9B%9B)%E2%80%94%E2%80%94%E8%B5%B0%E6%A3%8B%E5%8E%9F%E7%90%86%E5%8F%8A%E6%9D%83%E5%80%BC%E8%AE%A1%E7%AE%97/"},{"title":"C++实现服务器与客户端网络通讯","text":"说明 本程序并没有区分服务端与客户端，只是调用函数不同 基于socket网络编程 第一次写，代码格式不怎么规范，请谅解 基于Linux，Win版本目前没写 接下来准备基于本程序搞一个更大的项目 说明：ClientInfor(); 为客户端使用ServerInfor(); 为服务端使用二者不能同时用，因为用了相同的buf变量通过adjust变量作为函数参数来切换收发消息 原理此处暂时省略，过段时间会补上 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;errno.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;#include&lt;netinet/in.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa/inet.h&gt;#include &lt;iostream&gt;const int MAXLINE = 4096;const int PORT = 2726;int sockfd, connfd; //sock句柄和连接句柄struct sockaddr_in SerAddr;char buf[MAXLINE];int size;using namespace std;int ServerSockConn(){ //检查连接并报错 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { cout &lt;&lt; &quot; Socket connect failed:&quot; &lt;&lt; errno &lt;&lt; endl; return 0; } //储存相关信息，如IP等 memset(&amp;SerAddr, 0, sizeof(SerAddr)); SerAddr.sin_family = AF_INET; SerAddr.sin_port = htons(PORT); SerAddr.sin_addr.s_addr = htonl(INADDR_ANY); //检测绑定并报错 if (bind(sockfd, (struct sockaddr*)&amp;SerAddr, sizeof(SerAddr)) == -1) { cout &lt;&lt; &quot;Bind socket failed: &quot; &lt;&lt; errno &lt;&lt; endl; return 0; } //检测监听并报错 if( listen(sockfd, 10) == -1) { cout &lt;&lt; &quot;Listen socket failed: &quot; &lt;&lt; errno &lt;&lt; endl; return 0; }}void GetInfor(){ recv(connfd, buf, MAXLINE, 0); cout &lt;&lt; buf &lt;&lt; endl; close(connfd);}void SendInfor(){ send(connfd, &quot;Send&quot;, 15, 0);}//若为真则接收消息，若为假则发送消息void ServerInfor(bool adj){ ServerSockConn(); while(1) { if ( (connfd = accept(sockfd, (struct sockaddr*)NULL,NULL)) == -1) //同意请求 { cout &lt;&lt; &quot;Accept socket failed: &quot; &lt;&lt; errno &lt;&lt; endl; continue; } if (adj == true) { GetInfor(); } else { SendInfor(); } } close(sockfd);}//客户端int socketfd,n;char recvline[MAXLINE], sendline[MAXLINE];struct sockaddr_in CliAddr;//真收，假发int ClientInfor(bool adj){ socketfd = socket(AF_INET,SOCK_STREAM,0); //建立连接 if (socketfd == -1) { cout &lt;&lt; &quot;Socket failed:&quot; &lt;&lt; errno &lt;&lt; endl; } CliAddr.sin_family=AF_INET; CliAddr.sin_port=htons(PORT); CliAddr.sin_addr.s_addr=inet_addr(&quot;&quot;); //引号内为服务器公网IP bzero(&amp;(CliAddr.sin_zero),8); if ( connect(socketfd,(struct sockaddr*)&amp;CliAddr,sizeof(struct sockaddr)) == -1 ){ cout &lt;&lt; &quot;Connect failed:&quot; &lt;&lt; errno &lt;&lt; endl; } else { if (adj == true) { recv(socketfd,buf,MAXLINE,0); cout &lt;&lt; buf &lt;&lt; endl; } else { cout &lt;&lt; &quot;Please input&quot; &lt;&lt; endl; send(socketfd,&quot;conn&quot;,15,0); close(socketfd); } } }int main(){ //修改adjust变量来控制消息收发，为真则默认收，为假则发送 bool adjust = false; /* 说明： ClientInfor(); 为客户端使用 ServerInfor(); 为服务端使用 二者不能同时用，因为用了相同的buf变量 通过adjust变量作为函数参数来切换收发 */ return 0; }","link":"/2020/05/01/C++%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/"},{"title":"C++最小二乘计算回归方程","text":"介绍用来理解一下数学思路和练习一下代码。即兴而写的，所以没写注释。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;// #include &quot;Windows.h&quot;double sum_square_x = 0;double sum_x = 0;double sum_y = 0;double sum_xy = 0;int n = 0;double ave_x = 0;double ave_y = 0;double b_ba = 0;double a_ba = 0;using namespace std;void InputAndSum(){ cout &lt;&lt; &quot;请输入n的值&quot; &lt;&lt; endl; cin &gt;&gt; n; cout &lt;&lt; &quot; &quot; &lt;&lt; endl; double data_x = 0; double data_y = 0; int i = 1; while (i &lt;= n) { cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i &lt;&lt; &quot;个数据的x值&quot; &lt;&lt; endl; cin &gt;&gt; data_x; cout &lt;&lt; &quot; &quot; &lt;&lt; endl; cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i &lt;&lt; &quot;个数据的y值&quot; &lt;&lt; endl; cin &gt;&gt; data_y; cout &lt;&lt; &quot; &quot; &lt;&lt; endl; sum_x += data_x; sum_y += data_y; sum_xy += (data_x * data_y); sum_square_x += (data_x * data_x); i++; }}double Average(double a){ double ave = a / n; return ave;}double B_ba(double calc1,double calc2){ double square_ave_x = calc1 * calc1; double calc3; calc3 = (sum_xy - n * calc1 * calc2) / (sum_square_x - n * square_ave_x); return calc3;}void A_ba(){ a_ba = ave_y - b_ba * ave_x;}int main(){ InputAndSum(); ave_x = Average(sum_x); ave_y = Average(sum_y); b_ba = B_ba(ave_x,ave_y); A_ba(); cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;n的值为： &quot; &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; &quot;各x的和为： &quot; &lt;&lt; sum_x &lt;&lt; endl; cout &lt;&lt; &quot;各y的和为： &quot; &lt;&lt; sum_y &lt;&lt; endl; cout &lt;&lt; &quot;各个xy乘积的求和为： &quot; &lt;&lt; sum_xy &lt;&lt; endl; cout &lt;&lt; &quot;各个x平方的求和为： &quot; &lt;&lt; sum_xy &lt;&lt; endl; cout &lt;&lt; &quot;x的均值为： &quot; &lt;&lt; ave_x &lt;&lt; endl; cout &lt;&lt; &quot;y的均值为： &quot; &lt;&lt; ave_y &lt;&lt; endl; cout &lt;&lt; &quot;a(ba)为： &quot; &lt;&lt; a_ba &lt;&lt; endl; cout &lt;&lt; &quot;b(ba)为： &quot; &lt;&lt; b_ba &lt;&lt; endl; cout &lt;&lt; &quot;样本点中心为：(&quot; &lt;&lt; ave_x &lt;&lt; &quot;,&quot; &lt;&lt; ave_y &lt;&lt; &quot;)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;回归直线方程为 y = &quot; &lt;&lt; b_ba &lt;&lt; &quot;x + &quot; &lt;&lt; &quot;(&quot; &lt;&lt; a_ba &lt;&lt; &quot;)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl; //system(&quot;pause&quot;);}","link":"/2020/04/22/C++%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E8%AE%A1%E7%AE%97%E5%9B%9E%E5%BD%92%E6%96%B9%E7%A8%8B/"},{"title":"C++五子棋(二)——游戏界面与棋子渲染","text":"准备我们首先要在程序中定义一个名为drawPNG的函数，用于输出png格式图片并使背景透明 引入头文件(需要提前安装EasyX) 1#include &lt;graphics.h&gt; 定义函数 drawPNG 123456789101112131415161718192021222324252627282930313233343536void drawPNG(IMAGE* picture, int picture_x, int picture_y) //x为载入图片的X坐标，y为Y坐标{ // 变量初始化 DWORD* dst = GetImageBuffer(); // GetImageBuffer()函数，用于获取绘图设备的显存指针，EASYX自带 DWORD* draw = GetImageBuffer(); DWORD* src = GetImageBuffer(picture); //获取picture的显存指针 int picture_width = picture-&gt;getwidth(); //获取picture的宽度，EASYX自带 int picture_height = picture-&gt;getheight(); //获取picture的高度，EASYX自带 int graphWidth = getwidth(); //获取绘图区的宽度，EASYX自带 int graphHeight = getheight(); //获取绘图区的高度，EASYX自带 int dstX = 0; //在显存里像素的角标 // 实现透明贴图 公式： Cp=αp*FP+(1-αp)*BP ， 贝叶斯定理来进行点颜色的概率计算 for (int iy = 0; iy &lt; picture_height; iy++) { for (int ix = 0; ix &lt; picture_width; ix++) { int srcX = ix + iy * picture_width; //在显存里像素的角标 int sa = ((src[srcX] &amp; 0xff000000) &gt;&gt; 24); //0xAArrggbb;AA是透明度 int sr = ((src[srcX] &amp; 0xff0000) &gt;&gt; 16); //获取RGB里的R int sg = ((src[srcX] &amp; 0xff00) &gt;&gt; 8); //G int sb = src[srcX] &amp; 0xff; //B if (ix &gt;= 0 &amp;&amp; ix &lt;= graphWidth &amp;&amp; iy &gt;= 0 &amp;&amp; iy &lt;= graphHeight &amp;&amp; dstX &lt;= graphWidth * graphHeight) { dstX = (ix + picture_x) + (iy + picture_y) * graphWidth; //在显存里像素的角标 int dr = ((dst[dstX] &amp; 0xff0000) &gt;&gt; 16); int dg = ((dst[dstX] &amp; 0xff00) &gt;&gt; 8); int db = dst[dstX] &amp; 0xff; draw[dstX] = ((sr * sa / 255 + dr * (255 - sa) / 255) &lt;&lt; 16) //公式： Cp=αp*FP+(1-αp)*BP ； αp=sa/255 , FP=sr , BP=dr | ((sg * sa / 255 + dg * (255 - sa) / 255) &lt;&lt; 8) //αp=sa/255 , FP=sg , BP=dg | (sb * sa / 255 + db * (255 - sa) / 255); //αp=sa/255 , FP=sb , BP=db } } }} 初始化游戏创建游戏界面素材大小 通过查看res素材文件夹下的棋盘2.jpg可知，图片大小为897*895 通过图片大小计算可得一个格子的大小为67.4 先记下这些参数，后面对我们开发特别重要 创建窗口 首先，定义 float类型常量 BLOCKSIZE，即格子大小 1const float BLOCKSIZE = 67.4; 然后定义 init() 如下 1234void init(){ initgraph(897,895); //创建897*895大小的窗口，与棋盘2.jpg大小对应 loadimage(0,&quot;res/棋盘2.jpg&quot;); //加载图片到窗口} 加载音乐 引入播放音乐的 头文件 mmsystem.h 1#include &lt;mmsystem.h&gt; 加载库 winmm.lib 1#pragma comment(lib,&quot;winmm.lib&quot;); 继续在 init() 函数中添加播放 提示语音(res/start.wav) 的语句(注意添加位置) 1mciSendString(&quot;play res/start.wav&quot;,0,0,0); //提示下棋语音 棋子渲染加载素材 定义 IMAGE 类型的全局变量 chessWhite 和 chessBlack 12IMAGE chessWhite; //黑棋子变量IMAGE chessBlack; //白棋子变量 在 init() 函数定义中添加加载图片语句如下(将black.png白棋子素材和white.png黑棋子素材加载到变量) 123//长和宽都是BLOCKSIZE，最后一个true参数表示原比例缩放防止图片被截断loadimage(&amp;chessBlack, &quot;res/black.png&quot;,BLOCKSIZE,BLOCKSIZE,true);loadimage(&amp;chessWhite, &quot;res/white.png&quot;, BLOCKSIZE, BLOCKSIZE, true); 实现渲染 定义棋子种类 1234typedef enum{ CHESS_WHITE = -1, CHESS_BLACK = 1} chess_kind_t; 在实现输出棋子之前我们需要来看几个数据 MARGIN_X为上边界大小，MARGIN_Y为左边界大小，因此我们定义同名全局常量 1234const int MARGIN_X = 44;const int MARGIN_Y = 43;const int BOARD_GRAD_SIZE = 13; //13*13棋盘大小 之后定义函数 chessDown() 用于打印棋子图片 12345678910111213141516171819void chessDown(int row, int col, chess_kind_t kind){ mciSendString(&quot;play res/down7.wav&quot;,0,0,0); //播放下棋音乐 //EasyX是以窗口左上角为坐标原点 //定义棋子x横坐标 int x = MARGIN_X + col * BLOCKSIZE - 0.5 * BLOCKSIZE; //定义棋子y纵坐标 int y = MARGIN_Y + row * BLOCKSIZE - 0.5 * BLOCKSIZE; //判断棋子种类并打印 if(kind == CHESS_WHITE){ drawPNG(&amp;chessWhite,x,y); }else{ drawPNG(&amp;chessBlack,x,y); } } 结束到了这里，我们已经实现了游戏界面的初始化和棋子渲染了，接下来我们就要实现获取鼠标信息来判断有效点击了","link":"/2021/06/30/C++%E4%BA%94%E5%AD%90%E6%A3%8B(%E4%BA%8C)%E2%80%94%E2%80%94%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2%E4%B8%8E%E6%A3%8B%E5%AD%90%E6%B8%B2%E6%9F%93/"},{"title":"C&#x2F;C++在Win32控制台播放Bad Apple","text":"前言效果展示 ###提示###这里首先你需要准备一些文件，将一个Bad Apple的视频分别转换成txt和mp3格式(mp3用来作为背景音乐)我将txt文件放到exe文件目录下的子目录files里了转换方法可以用Adobe,这里不做详细介绍，你可以下载我已经准备好的文件，在文章末尾会给出连接 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;mmsystem.h&gt;#pragma comment (lib,&quot;Winmm.lib&quot;) //加载windows播放音乐的库#define MAX_ROW 66#define MAX_COL 150#define MAX_FRAME 13148char map[MAX_FRAME][MAX_ROW][MAX_COL+1];void init(){ SetConsoleTitle(&quot;BadApple&quot;); //控制台标题 system(&quot;mode con cols=151 lines=68&quot;); HANDLE hout = GetStdHandle(STD_OUTPUT_HANDLE); CONSOLE_CURSOR_INFO info = { 1,0 }; SetConsoleCursorInfo(hout, &amp;info);}//读取文件void readData() { FILE* fp; //文件指针 char fileName[128]; //文件名 for (int i = 0; i &lt; MAX_FRAME; i++) { //每次读取一个文件 int row = 0; sprintf(fileName, &quot;files/ASCII-badApple60fps%05d.txt&quot;, i); //生成一个文件名 fp = fopen(fileName, &quot;r&quot;); if (fp == NULL) { exit(1); } //当文件读完时结束循环 while (!feof(fp)) { fgets(map[i][row],200,fp); map[i][row][MAX_COL] = '\\0'; //取消每行最后的回车符 row++; } fclose(fp); }}//播放动画函数void play() { system(&quot;cls&quot;); //清屏 for (int i = 0; i &lt; MAX_FRAME; i++) { for (int j = 0; j &lt; MAX_ROW; j++) { //如果用printf()的话由于之前我们取消了换行符，所以要在此处加上 puts(map[i][j]); //不断打印到每一行 } Sleep(2); //休眠2毫秒 //把光标引到最前方 HANDLE houtput = GetStdHandle(STD_OUTPUT_HANDLE); //控制台 COORD loc; //引入结构体，并定义xy初始坐标 loc.X = 0; loc.Y = 0; SetConsoleCursorPosition(houtput, loc); }}int main(void) { init(); //初始化 //将文本文件加载到计算机内存 readData(); //开始播放 while (1) { //播放背景音乐 mciSendString(&quot;play bg.mp3&quot;, 0, 0, 0); play(); } return 0;} 文件百度网盘链接：https://pan.baidu.com/s/1i8UEQsw5UPoLX7S41Xk9Hw提取码：8848","link":"/2020/08/18/C-C++%E5%9C%A8Win32%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%92%AD%E6%94%BEBad-Apple/"},{"title":"CSS将网页设置为全灰色","text":"内容今天是清明节，是沉重的一天，是因新冠肺炎牺牲者的哀悼日。许多博客和网站都设置为灰色色调，下面讲述设置方法。 在自定义css或者主题css文件中添加以下代码 123html{-webkit-filter: grayscale(100%);}","link":"/2020/04/04/CSS%E5%B0%86%E7%BD%91%E9%A1%B5%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%85%A8%E7%81%B0%E8%89%B2/"},{"title":"C语言模块化编程","text":"说明 C程序可以只有一个main()函数。包含main()函数的模块叫做主模块(main module),其它模块叫做**次模块(secondary module)**。通常，每个次模块都通过一个头文件相关联。 环境这里仅在Linux环境下调试，其他环境暂不说明 代码内容说明 依次是主模块、次模块、头文件，读取用户输入数字并输出该数字的平方 ###代码### test.c 主模块 123456789101112#include &lt;stdio.h&gt;#include &quot;calc.h&quot; //注意，这里头文件为自己所写，必须用英文引号。int main(void){ int x; printf(&quot;Enter an integer value: &quot;); scanf(&quot;%d&quot;,&amp;x); //如果您用的是Visual Studio的话，这里可能会需要用 scanf_s(); printf(&quot;\\nThe square of %d is %ld.\\n&quot;, x, sqr(x)); //这里的sqr();在后面文件中会定义 return(0);} calc.c 次模块 1234567#include &quot;calc.h&quot; //注意，这里头文件为自己所写，必须用英文引号。long sqr(int x){ return ((long)x * x);} calc.h 头文件 1long sqr(int x); 连接1234gcc -c test.cgcc -c calc.cgcc -o test test.o calc.o./test 注: -c是只编译 输出结果如下(以输入100为例子)： 12Enter an integer value: 100The square of 100 is 10000.","link":"/2020/07/06/C%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"},{"title":"Debian系(Ubuntu)安装deepin-wine来使用常用软件","text":"介绍deepin-wine一开始是专门针对deepin系统用的，这里还多亏了deepin开发团队，使之能够适配其他Debian系列的Linux系统利用deepin-wine可以安装QQ,迅雷，微信，百度网盘等常用软件这里以Ubuntu为例 步骤安装环境 执行克隆1git clone https://github.com/wszqkzqk/deepin-wine-ubuntu.git 访问速度慢可以用gitee1git clone https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git 进入目录，然后执行sudo ./install.sh 安装软件使用deepin发布的容器安装包（不一定不是最新版，但稳定性好） QQ TIM QQ轻聊版 微信 百度网盘 360压缩 迅雷极速版 WinRAR 千牛卖家工作台 托盘安装TopIcons Plus 其他更多请参考： https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu或https://github.com/wszqkzqk/deepin-wine-ubuntu","link":"/2020/04/07/Debian%E7%B3%BB(Ubuntu)%E5%AE%89%E8%A3%85deepin-wine%E6%9D%A5%E4%BD%BF%E7%94%A8%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"},{"title":"HTML5 form标签method属性post与get的区别","text":"post写法: 12&lt;form action=&quot;&quot; method=&quot;post&quot;&gt; ... &lt;/form&gt; &lt;!-- action属性添加url --&gt; get写法: 123&lt;form action=&quot;&quot; method=&quot;post&quot;&gt; ... &lt;/form&gt; &lt;!-- action属性添加url --&gt; 区别 get请求的数据会附在URL之后，如图post把提交的数据放置在HTTP包的包体中,当提交数据需要的保密性高或数据量大时使用较多,传递数据隐匿","link":"/2020/03/03/HTML5-form%E6%A0%87%E7%AD%BEmethod%E5%B1%9E%E6%80%A7post%E4%B8%8Eget%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"HTML5 input标签常使用类型","text":"12345678type=&quot;text&quot; &lt;!--文本输入框--&gt; type=&quot;password&quot; &lt;!--密码输入框--&gt; type=&quot;radio&quot; &lt;!--单选框--&gt; type=&quot;checkbox&quot; &lt;!--复选框--&gt; type=&quot;button&quot; &lt;!--普通按钮--&gt; type=&quot;submit&quot; &lt;!--提交按钮--&gt; type=&quot;reset&quot; &lt;!--重置按钮--&gt; type=&quot;file&quot; &lt;!--文件选择框--&gt; 目前基本上都用 js 写交互，但作为一个初学者了解下还是有必要的。","link":"/2020/03/03/HTML5-input%E6%A0%87%E7%AD%BE%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B/"},{"title":"HTML学习笔记——单双标签","text":"单双标签单标签12345678910111213&lt;!-- 换行符 --&gt;&lt;br/&gt;&lt;!-- 水平线 --&gt;&lt;hr/&gt;&lt;!-- 图片标签 --&gt;&lt;img/&gt;&lt;!-- 文本标签 --&gt;&lt;input/&gt;&lt;!-- link标签 --&gt;&lt;link/&gt;&lt;!-- 元信息标签 --&gt;&lt;meta/&gt; 双标签由 “开始标签” 和 “结束标签” 两部分组成，必须成对使用。 常见的有 12345678&lt;p&gt;&lt;/p&gt;&lt;html&gt;&lt;/html&gt;&lt;title&gt;&lt;/title&gt;&lt;body&gt;&lt;/body&gt;&lt;table&gt;&lt;/table&gt;&lt;span&gt;&lt;/span&gt;&lt;div&gt;&lt;/div&gt;&lt;h1&gt;&lt;/h1&gt;","link":"/2020/03/30/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8D%95%E5%8F%8C%E6%A0%87%E7%AD%BE/"},{"title":"C语言运算符","text":"最高级1234() 圆括号[] 下标运算符号-&gt; 指向结构体成员运算符. 结构体成员运算符 第二级123456789! 逻辑非运算符~ 按位取反运算符++ 自增运算符-- 自减运算符- 负号运算符(type) 类型转换运算符* 指针运算符&amp; 取址运算符sizeof 长度运算符 第三级12345*乘法运算符/除法运算符%取余运算符+加法运算符-减法运算符 第四级12&lt;&lt; 左移运算符 00001111变成00011110&gt;&gt; 右移运算符 00001111变成00000111 第五级123&lt; &lt;= &gt; &gt;= 关系运算符!= 不等运算符== 等于运算符 第六级123&amp; 按位运算符^ 按位异或运算符| 按位或运算符 第七级123&amp;&amp; (表达式1)&amp;&amp;(表达式2) 表达式1不成立，不考虑表达式2，直接返回0|| (表达式1)||(表达式2) 表达式1成立，不考虑表达式2，直接返回1&amp;&amp;优先级大与|| 第八级1234? : 例： z=x&gt;y?x:y 如果x&gt;y,把x赋值给z 如果x&lt;=y,把y赋值给z 第九级123456=+=-+*=/=%= 最低级1,","link":"/2020/03/24/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"C语言结构体指针与结构体变量作形参的区别","text":"区别结构体变量 结构体变量作为形参，传递的是结构体变量本身，是一种值传递 形参结构体变量成员值的改变不影响对应的实参构体变量成员值的改变 结构体指针 结构体指针作为函数参数，传递的是指向结构体变量的本身 结构体指针指向的变量成员值的改变影响对应的实参构体变量成员值的改变 代码直接说有些抽象难懂，敲代码演示一遍就很清楚了 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct stru{ int num;};//形参为结构体变量void addNum(struct stru p, int num2){ p.num += num2;}//形参为结构体指针void addNum2(struct stru *p, int num2){ if(!p) return; //确保指针不为空指针 p-&gt;num += num2;}int main(){ struct stru t; t.num = 50; addNum(t,5000); printf(&quot;形参为结构体变量得到的结果为: %d\\n&quot;, t.num); addNum2(&amp;t,5000); printf(&quot;形参为结构体指针得到的结果为: %d\\n&quot;, t.num); return 0; } 输出结果12形参为结构体变量得到的结果为: 50形参为结构体指针得到的结果为: 5050","link":"/2021/07/31/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E4%BD%9C%E5%BD%A2%E5%8F%82%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"CuteBot智能小车","text":"原因近期，别人送了我一个CuteBot智能小车，拆开一看做工挺精致的，但是这东西是积木图形编程，显然不适合我这个年龄，所以打算给家里的小孩玩。 那么，你可能会问了，为什么要写这篇文章呢？答案当然是用来水的啊 其实在装的时候遇到了点坑，所以记录下来（说了半天还是水文章（滑稽）） 部件首先看下一个具有完整功能的 CuteBot小车（不算拓展）分为几个部分吧 MicroBit主板 这可以说是最核心的部件了，给小车烧录程序也是通过它。Microbit是由英国BBC公司推出的面向青少年编程教育的微型计算机，集成了加速度传感器，磁力传感器，两个可编程按钮，25个单色led，蓝牙等常用传感器设备，有一个micro usb接口用于连接数据线烧写程序和供电，可外接电池盒，底部有多个环孔连接器用于控制外接设备。这个板子不仅仅可以用于小车，官方还有许多套件，如智能家居等。当然也可以仅用这个板子跑程序，亮Led，放音乐等。总之它的功能非常强大。 电池盒 SR04超声波模块 小车主体 (电池盒是粘上去的，实在是弄不下来了) 组装 首先将电池盒的线接到小车主板上并将电池盒粘到小车上 然后插入超声波模块（注意：超声波模块插槽为8Pin，要插入到插槽的前4个孔上，千万不要插入后四个插孔，否则小车无法跑起来，超声波模块会发烫） 如图： 最后将MicroBit插入的小车上的蓝色插槽里（MicroBit背面朝电池盒） 组装完成 编程环境 将MicroBit通过数据线连接上PC 打开网站 https://makecode.microbit.org 点击“新建项目” 输入项目名 “高级” -&gt; “扩展” 搜索CuteBot ，并点击 返回页面你就会发现有了“酷比特小车”一行了 点击“…” -&gt; Connect 根据提示连接小车即可 Hello World 现在开始编写第一个程序吧，你可以选择图形化的“方块”编程，也可以用JavaScript或Python编程（这里我用JS） 输入代码 12345678910111213141516/*这部分是开机执行 *///在MicroBit显示屏（Led）上显示字符串 Hello,World!basic.showString(&quot;Hello，World!&quot;)//显示完后，以50%的速度向前方行驶5秒cuteBot.moveTime(cuteBot.Direction.forward,50,5)basic.forever(function () { /* 这里是无限循环的代码块 */}) 点击“下载” ，代码就开始执行了 （注意：如果该网站没有连接到MicroBit，那么你需要下载文件并右键手动发送到MicroBit里） 结束该小车的优点是不需要焊接电路，并且无需搭配环境，仅需要组装好小车并通过在线编程即可运行 由于篇幅有限，关于API使用可以参考官方文档 https://microbit.org/zh-cn/get-started/first-steps/introduction/ https://archive.microbit.org/zh-CN/guide/quick/ （英文）https://microbit-micropython.readthedocs.io/en/latest/tutorials/hello.html","link":"/2021/07/20/CuteBot%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/"},{"title":"HTML学习笔记——文本格式化标签","text":"文本格式化标签b和strong1234&lt;!-- 都是行级标签（不会自动换行），都有加粗作用 --&gt;&lt;!-- strong具有强调作用 -- &gt;&lt;b&gt;...&lt;/b&gt; &lt;strong&gt;...&lt;/strong&gt; i和em1234&lt;!-- 都可以使文字倾斜，都是行级标签。简单的倾斜效果用i标签就可以 --&gt;&lt;!-- em还具有强调作用 --&gt;&lt;i&gt;...&lt;/i&gt;&lt;em&gt;...&lt;/em&gt; pre预格式文本123&lt;!-- 预格式化文本，保留换行和宽度，但字号会小一号 --&gt;&lt;!-- 块级标签，会独占一行 --&gt;&lt;pre&gt;...&lt;/pre&gt; small和big12345678&lt;!-- 浏览器支持的最小字号为12px，要显示更小的字需另行处理。 --&gt;&lt;!-- 都是行级标签 -- &gt;&lt;!-- small会使文字小一号 --&gt;&lt;small&gt;...&lt;/small&gt;&lt;!-- big会使文字大一号。big在html5中已淘汰但没删除，开发中尽量不要使用。 --&gt;&lt;big&gt;...&lt;/big&gt; sub和sup12345&lt;!-- sub为文本下标 --&gt;&lt;sub&gt;...&lt;/sub&gt;&lt;!-- sup为文本上标 --&gt;&lt;sup&gt;...&lt;/sup&gt; 如图所示","link":"/2020/03/30/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%87%E7%AD%BE/"},{"title":"Handsome主题使用后感受","text":"印象对于typecho来说，handsome算的上是个经典主题了。刚刚购买的时候感觉有些小贵(对于我这个穷逼学生党来说)，但安装完体验一番的时候感到物有所值，88元的价格还真不算过分。然后，它给我留下的印象是功能强大且复杂，甚至我花了一整天的时间去研究它的配置（困）。 感受我比较喜欢的是它自带的播放器，这使得我不用再去找其他插件。其次6.0版本自带links插件(Handsome插件)，但头一次使用会显示无效链接，编辑链接会进入404界面。我折腾了半天都没有搞定，最后向作者询问，发现只需要将Handsome插件重启一下就好了（差点气到吐血）。 不足我个人认为Handsome主题有以下两点不足（个人认为，勿喷）： 反复配置太过复杂，能精简一些就好了 原生主题美化有些单一我尽量通过百度解决后一个问题，成功对 头像 指针 等进行美化，当然这仍需折腾。不过这也不算什么，正如友链大佬 探索;实践 所说：“生命不息，折腾不止”。最后，我实在撑不下去了，文章就写到这里，去睡觉（滑稽）。 其它购买：https://www.ihewro.com/archives/489/ 美化： https://www.xcnte.com/archives/710/ https://www.mgxfd.club/20.html(推荐先看) 操作： https://blog.mioshu.com/archives/52.html https://handsome.ihewro.com/#/ （官方）","link":"/2020/03/28/Handsome%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E5%90%8E%E6%84%9F%E5%8F%97/"},{"title":"循环链表应用——约瑟夫置换","text":"约瑟夫问题介绍约瑟夫问题，又称约瑟夫置换、丢手绢问题。 一般形式（本部分内容来自百度百科） 约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3。 代码问题描述本文以以下问题为例 编号为1-10的10 个人围成一圈，从第一个开始报数，第9个被淘汰出圈，剩下的组成新的圈。依次这样下去，求最后一个人的编号 解决注意：该段代码与上篇文章——《 循环链表定义及操作 》相接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//解答约瑟夫问题bool Joseph(LinkList* &amp;L, int interval){ LinkList *p = L, *q; int i = 0, j = 0; int times = 0; //当前轮数 int num = 0; if(!L || p-&gt;next == L) { cout &lt;&lt; &quot;链表为空\\n&quot;; return false; } if(interval &lt; 1) { cout &lt;&lt; &quot;报数淘汰口令不能小于1\\n&quot;; return false; } do{ i += interval; //找查第i个结点，p指向该结点的上一个结点 while(p-&gt;next){ if(p-&gt;next != L) { //如果不是头结点的话 j++; } if(j &gt;= i) break; p = p-&gt;next; } times++; q = p-&gt;next; //临时保存被删结点以备释放空间 num = q-&gt;data; cout &lt;&lt; &quot;当前结点:&quot; &lt;&lt; q-&gt;data &lt;&lt; &quot; 上一个结点:&quot; &lt;&lt; p-&gt;data &lt;&lt;&quot; 下一个结点:&quot; &lt;&lt; q-&gt;next-&gt;data &lt;&lt; endl; p-&gt;next = q-&gt;next; delete q; //释放被删除结点内存 LinkListPrint(L); }while(L-&gt;next != L); //链表不为空，继续报数 cout &lt;&lt; &quot;最后一个出圈者的编号&quot; &lt;&lt; num &lt;&lt; endl; return true;} 完整代码代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;typedef struct _LinkNode{ int data; struct _LinkNode *next;}LinkList;bool InitList(LinkList* &amp;L){ L = new LinkList; if(!L) return false; L-&gt;next = L; L-&gt;data = 0; return true;}bool ListInsert_back(LinkList* &amp;L, LinkList *node){ LinkList *last = NULL; if(!L || !node) return false; if(L == L-&gt;next) { //头结点指针指向了自己（链表只有头结点） node-&gt;next = L; L-&gt;next = node; }else{ //非空的循环链表 last = L-&gt;next; //寻找尾结点（指向头结点的结点） while(last-&gt;next != L) { last = last-&gt;next; } node-&gt;next = L; last-&gt;next = node; } return true;}void LinkListPrint(LinkList *L){ LinkList *p; if(!L || L == L-&gt;next) { cout &lt;&lt; &quot;链表为空\\n&quot;; return; } p = L-&gt;next; while(p != L) { cout &lt;&lt; p-&gt;data &lt;&lt; &quot;\\t&quot;; p = p-&gt;next; } cout &lt;&lt; endl;}//解答约瑟夫问题bool Joseph(LinkList* &amp;L, int interval){ LinkList *p = L, *q; int i = 0, j = 0; int times = 0; //当前轮数 int num = 0; if(!L || p-&gt;next == L) { cout &lt;&lt; &quot;链表为空\\n&quot;; return false; } if(interval &lt; 1) { cout &lt;&lt; &quot;报数淘汰口令不能小于1\\n&quot;; return false; } do{ i += interval; //找查第i个结点，p指向该结点的上一个结点 while(p-&gt;next){ if(p-&gt;next != L) { //如果不是头结点的话 j++; } if(j &gt;= i) break; p = p-&gt;next; } times++; q = p-&gt;next; //临时保存被删结点以备释放空间 num = q-&gt;data; cout &lt;&lt; &quot;当前结点:&quot; &lt;&lt; q-&gt;data &lt;&lt; &quot; 上一个结点:&quot; &lt;&lt; p-&gt;data &lt;&lt;&quot; 下一个结点:&quot; &lt;&lt; q-&gt;next-&gt;data &lt;&lt; endl; p-&gt;next = q-&gt;next; delete q; //释放被删除结点内存 LinkListPrint(L); }while(L-&gt;next != L); //链表不为空，继续报数 cout &lt;&lt; &quot;最后一个出圈者的编号&quot; &lt;&lt; num &lt;&lt; endl; return true;}int main(){ LinkList *L, *s; int i = 0; if(InitList(L)) { cout &lt;&lt; &quot;创建一个空的循环链表\\n&quot;; }else{ exit(-1); } cout &lt;&lt; &quot;尾插10个元素...\\n&quot;; while((++i)&lt;=10) { s = new LinkList; s-&gt;data = i; s-&gt;next = NULL; if(ListInsert_back(L, s)) { cout &lt;&lt; &quot;success\\n&quot;; }else{cout &lt;&lt; &quot;default\\n&quot;;} } LinkListPrint(L); Joseph(L,9); return 0;} 输出结果注：0为头结点的数据，该结点并不计入约瑟夫环中（但最后也将其删除销毁链表释放内存） 12345678910111213141516171819202122232425262728293031323334创建一个空的循环链表尾插10个元素...successsuccesssuccesssuccesssuccesssuccesssuccesssuccesssuccesssuccess1 2 3 4 5 6 7 8 9 10 当前结点:9 上一个结点:8 下一个结点:101 2 3 4 5 6 7 8 10 当前结点:8 上一个结点:7 下一个结点:101 2 3 4 5 6 7 10 当前结点:10 上一个结点:7 下一个结点:01 2 3 4 5 6 7 当前结点:2 上一个结点:1 下一个结点:31 3 4 5 6 7 当前结点:5 上一个结点:4 下一个结点:61 3 4 6 7 当前结点:3 上一个结点:1 下一个结点:41 4 6 7 当前结点:4 上一个结点:1 下一个结点:61 6 7 当前结点:1 上一个结点:0 下一个结点:66 7 当前结点:6 上一个结点:0 下一个结点:77 当前结点:7 上一个结点:0 下一个结点:0链表为空最后一个出圈者的编号7","link":"/2021/09/18/Joseph/"},{"title":"HTML学习笔记——实体转义与块级行级元素","text":"转义字符1234567&amp;lt; &lt;!-- 小于号（&lt;） --&gt;&amp;gt; &lt;!-- 大于号（&gt;） --&gt;&amp;amp; &lt;!-- 与号（&amp;） --&gt;&amp;nbsp; &lt;!-- 空格 --&gt;&amp;copy; &lt;!-- 版权号（©） --&gt;&amp;times; &lt;!-- 乘号（×） --&gt;&amp;divide; &lt;!-- 除号（÷） --&gt; 块级元素与行级元素块级元素** 特性： ** 相当于执行display:block操作 独占一行 ** 宽度和高度都是可控的，如果没设置其宽度，将默认铺满整行 ** 其内部可以包含块级元素和行级元素 如下： 12&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt; 行级元素** 特性： ** 相当于执行了display:inline 不会独占一行，与相邻的行级元素占同一行，直到占满，会自动掉到下一行 ** 宽度和高度不可控 ** 其内部只能包含行级元素 如下： 12&lt;strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;/span&gt; 区别分别给 * 块级元素p标签 * 和 * 行级元素span标签 * 设置如下属性 1234&lt;p style=&quot;width:300px; height:50px; background:gray;&quot;&gt;p&lt;/p&gt;&lt;span style=&quot;width:300px; height:50px; background:gray;&quot;&gt;span&lt;/span&gt; 如图： 我们可以明显看出 * 块级元素p标签 * 独占一行且可控宽度和高度（看颜色）而 * 行级元素span标签* 并不独占一行，且不可控宽度和高度（看颜色） 行级、块级元素相互转换二者可以相互转化，只需在其style中设置display的属性即可 例如： 12345&lt;!-- 块级标签p转换成行级 --&gt;&lt;p style=&quot;display:inline;&quot;&gt;&lt;/p&gt;&lt;!-- 行级标签span转换成块级 --&gt;&lt;span style=&quot;display:block&quot;&gt;&lt;/span&gt;","link":"/2020/03/30/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AE%9E%E4%BD%93%E8%BD%AC%E4%B9%89%E4%B8%8E%E5%9D%97%E7%BA%A7%E8%A1%8C%E7%BA%A7%E5%85%83%E7%B4%A0/"},{"title":"Linux Git命令提交仓库","text":"##命令## ###提交### 添加远程仓库 1git remote add origin https://... 添加所需上传的文件 1git add FileName 提交并添加信息 1git commit -m &quot;Information of your File&quot; 推送 1git push 然后会提示你输入用户名和密码 其他全局设定用户名 1git config --global user.name &quot;Your username&quot; Email 1git config --global user.email &quot;example@123.xxx&quot;","link":"/2020/07/19/Linux-Git%E5%91%BD%E4%BB%A4%E6%8F%90%E4%BA%A4%E4%BB%93%E5%BA%93/"},{"title":"Linux搭建Java国际版Minecraft服务器","text":"前提前提你要有一台运行内存不小于2GB的服务器 搭建安装安装Java 首先执行下方命令产看是否已安装Java,出现版本号就不用再次安装了1java -version 以Centos为例安装Java1sudo yum install java-1.8.0-openjdk 安装Screen 执行下方命令安装Screen (依然以CentOS为例)1sudo yum install screen 下载 首先你要在本地去官网或MCBBS下载服务端(网络原因推荐去MCBBS) 配置 将server.jar文件上传到服务器*(Win下可以用WinSCP等工具上传)* 用工具(Putty等)连接服务器，在服务器该文件的目录下执行以下命令1sudo java -Xms1024m -Xmx1024m -jar server.jar nogui 然后会产生许多文件，其中有一个叫eula.txt 用nano编辑它(报错的话就用命令安装sudo yum install nano )1sudo nano eula.txt 将其中的 eula = false 更改为 eula = true并Ctrl+O然后回车保存 非正版注意若您想要非正版用户登录服务器还需要额外步骤 执行以下命令 1sudo nano server.propertices 修改 online-mode:true 为 online-mode:false 然后保存 启动 创建一个新窗口给MC，防止关掉命令行时进程终止 1sudo screen -S mcserver 再次执行以下命令 1sudo java -Xms1024m -Xmx1024m -jar server.jar nogui 等到出现”help”就搭建完成了","link":"/2020/08/16/Linux%E6%90%AD%E5%BB%BAJava%E5%9B%BD%E9%99%85%E7%89%88Minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"Linux内核链表之共享双链表","text":"说明共享双链表意义在于，可以用一套函数维护不同数据类型的双链表 准备定义双链表123456789101112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//此处并不包含数据域，仅有指针域用于连接结点typedef struct _DbLinkList{ struct _DbLinkList *next; struct _DbLinkList *prev;}DbLinkList; 定义结构体123456789101112//定义数据类型，并挂载双链表的指针struct num{ int data; DbLinkList node; //此处不用指针，以保证在为该结构体分配内存时同时为双链表分配};struct str{ string data; DbLinkList node; //此处不用指针，以保证在为该结构体分配内存时同时为双链表分配}; 操作初始化1234567//因为在保存数据的结构体中未用双链表的指针，所以此处L使用引用而非引用类型的指针bool initList(DbLinkList &amp;L){ L.next = NULL; L.prev = NULL; return true;} 尾插法123456789101112bool insertBack(DbLinkList &amp;L, DbLinkList &amp;node){ DbLinkList *p = &amp;L; while(p-&gt;next) p = p-&gt;next; node.next = NULL; p-&gt;next = &amp;node; node.prev = p; return true;} 实际操作对于struct nummain函数12345678910111213141516171819202122232425262728293031int main(){ num *N = new num; N-&gt;data = -1; initList(N-&gt;node); //尾插法 num *n = new num; n-&gt;data = 2; insertBack(N-&gt;node, n-&gt;node); //用链表访问结点的数据 DbLinkList *p = &amp;(N-&gt;node); while(p) { //获取在结构体中node距离结构体顶点的距离 int offset = offsetof(num, node); /* * data地址 = 结构体底地址 - node距离结构体顶点的距离 * 但指针不能直接加减，所以要先转化为size_t类型，得到结果后再转为指针类型 */ num *tmp = (num *)((size_t)p - offset); cout &lt;&lt; &quot;NUM:&quot; &lt;&lt; tmp-&gt;data &lt;&lt; endl; p = p-&gt;next; } return 0;} 输出结果12NUM:-1NUM:2 对于struct str同理 main函数123456789101112131415161718192021222324252627282930int main(){ str *S = new str; S-&gt;data = &quot;hello,world&quot;; initList(S-&gt;node); //尾插法 str *s = new str; s-&gt;data = &quot;你好，世界&quot;; insertBack(S-&gt;node, s-&gt;node); //用链表访问结点的数据 DbLinkList *p = &amp;(S-&gt;node); while(p) { //获取在结构体中node距离结构体顶点的距离 int offset = offsetof(str, node); /* * data地址 = 结构体底地址 - node距离结构体顶点的距离 * 但指针不能直接加减，所以要先转化为size_t类型，得到结果后再转为指针类型 */ str *tmp = (str *)((size_t)p - offset); cout &lt;&lt; &quot;STR:&quot; &lt;&lt; tmp-&gt;data &lt;&lt; endl; p = p-&gt;next; } return 0;} 输出结果12STR:hello,worldSTR:你好，世界 (注意：本文没有做双链表的销毁操作，虽然程序可以正常运行但这样做是不可取的) 思考能不能将不同类型的结构体都放在一个双链表上？ 如果能该怎么读取数据？","link":"/2021/10/05/Linux%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%8F%8C%E9%93%BE%E8%A1%A8/"},{"title":"LoveKKComment插件修改邮件模版并美化","text":"方法[scode type=”yellow”]本插件版本1.0.5[/scode] 在该插件目录中找到reply.html文件，删除并新建reply.html写入以下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;table style=&quot;width:99.8%;height:99.8%&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; &lt;div style=&quot;background: white; width: 95%; max-width: 800px; margin: auto auto; border-radius: 5px; border:orange 1px solid; overflow: hidden; -webkit-box-shadow: 0px 0px 20px 0px rgba(0, 0, 0, 0.12); box-shadow: 0px 0px 20px 0px rgba(0, 0, 0, 0.18);&quot;&gt; &lt;header style=&quot;overflow: hidden;&quot;&gt; &lt;img style=&quot;width:100%;z-index: 666;&quot; src=&quot;https://ftp.bmp.ovh/imgs/2020/03/c124a3068b0ba6c8.jpg&quot;&gt; &lt;/header&gt; &lt;div style=&quot;padding: 5px 20px;&quot;&gt; &lt;p style=&quot;position: relative; color: white; float: left; z-index: 999; background: orange; padding: 5px 30px; margin: -25px auto 0 ; box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.30)&quot;&gt;Dear&amp;nbsp;{author}&lt;/p&gt; &lt;br&gt; &lt;h3&gt;您有一条来自&lt;a style=&quot;text-decoration: none;color: orange &quot; target=&quot;_blank&quot; href=&quot;{blogUrl}&quot;&gt;{blogName}&lt;/a&gt;的回复&lt;/h3&gt; &lt;br&gt; &lt;p style=&quot;font-size: 14px;&quot;&gt;您在文章《{title}》上发表的评论：&lt;/p&gt; &lt;p style=&quot;border-bottom:#ddd 1px solid;border-left:#ddd 1px solid;padding-bottom:20px;background-color:#eee;margin:15px 0px;padding-left:20px;padding-right:20px;border-top:#ddd 1px solid;border-right:#ddd 1px solid;padding-top:20px&quot;&gt;{text}&lt;/p&gt; &lt;p style=&quot;font-size: 14px;&quot;&gt;{replyAuthor} 给您的回复如下：&lt;/p&gt; &lt;p style=&quot;border-bottom:#ddd 1px solid;border-left:#ddd 1px solid;padding-bottom:20px;background-color:#eee;margin:15px 0px;padding-left:20px;padding-right:20px;border-top:#ddd 1px solid;border-right:#ddd 1px solid;padding-top:20px&quot;&gt;{replyText}&lt;/p&gt; &lt;div style=&quot;text-align: center;&quot;&gt; &lt;img src=&quot;https://ftp.bmp.ovh/imgs/2020/03/8423219bbff23d56.png&quot; alt=&quot;hr&quot; style=&quot;width:100%; margin:5px auto 5px auto; display: block;&quot;&gt; &lt;a style=&quot;text-transform: uppercase; text-decoration: none; font-size: 14px; border: 2px solid #6c7575; color: #2f3333; padding: 10px; display: inline-block; margin: 10px auto 0; &quot; target=&quot;_blank&quot; href=&quot;{permalink}&quot;&gt;点击查看回复的完整內容&lt;/a&gt; &lt;/div&gt; &lt;p style=&quot;font-size: 12px;text-align: center;color: #999;&quot;&gt;请勿直接回复&lt;br&gt; ©{blogName}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; ##相关参数## 12345678{blogUrl} //博客地址{blogName} //博客名称{author} //被回复者名称{permalink} //文章链接{title} //文章标题{text} //被回复者评论内容{replyAuthor} //回复者名称{replyText} //回复内容 效果展示 ##感谢## 感谢大佬 摩尔 的帮助","link":"/2020/03/21/LoveKKComment%E6%8F%92%E4%BB%B6%E4%BF%AE%E6%94%B9%E9%82%AE%E4%BB%B6%E6%A8%A1%E7%89%88%E5%B9%B6%E7%BE%8E%E5%8C%96/"},{"title":"Lumia一键刷稳定版 Win10 arm 及其报错处理","text":"前言之前我发了一篇Lumia1520 刷Win10 arm双系统的文章,不过后来发现那个方法对小白来说太不友好，且系统也不稳定，所以我找到了更好的方法 刷机我们可以利用刷机迷进行刷机，支持一键刷机操作和WP系统的还原备份更新以及WP应用安装等，甚至还有Root以及注册表编辑等功能。 至于教程，官网已经说的很清楚了（官方有文章和视频教程），而且各种Lumia机型都有，还提供了固件和其它文件的下载。 有兴趣的可以直接去官网看，不需要我再写教程了。 注意问题 一定要先看教程，尤其是解锁那段，不当操作会导致解锁不完全 如果再部署win10 arm的时候出现path路径报错，你需要手动给EFIESP分区一个盘符再进行部署(不知道什么是EFIESP的去看我上一篇文章) 如果你的PC装了杀毒软件，在过程中会拦截(毕竟安装系统会修改相关的dll文件)，你需要允许程序全部运行 一个思路我突然想到Win10 arm是无法运行仅支持X86框架的软件的，如果你想玩游戏可以用Steam串流玩，这样你就可以向别人吹：我能在手机上玩3A大作，你能吗？（滑稽）","link":"/2021/02/07/Lumia%E4%B8%80%E9%94%AE%E5%88%B7%E7%A8%B3%E5%AE%9A%E7%89%88%20Win10%20arm%20%E5%8F%8A%E5%85%B6%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/"},{"title":"Lumia1520手机刷Windows10 arm双系统","text":"注意问题 升级到Windows 10 Mobile的需重新刷回WP8.1，否则解锁会失败 部分手机刷机win10arm后出现屏幕卡死现象，目前除了换屏或重新焊接暂无其他解决方案，请谨慎刷机(当然如果遇到这种问题你也可以刷回原来的系统，还原你的手机) 本教程为双系统安装方式 给出的固件仅适用于Lumia1520 美版（RM940） 准备硬件 联网的 WIndows PC一台（PC系统最好是Win10其余系统没试过；硬盘要够用，因为接下来下载的软件比较大） NOKIA Lumia 1520 (最好先充电) Micro USB 数据线 软件首先软件我已经为大家准备好了，直接下载即可，不需要再折腾去收集了 https://pan.baidu.com/s/169ufHYn_zn-G0dr1GeopCw 提取码：8848 列表如下 固件RM1085_1078.0053.10586.13169.15217.034DAF_retail_prod_signed.ffu (在ffu固件压缩包内，解压即可得到) 固件 RM940_02540.00019.14484.37028_RETAIL_prod_signed_200_01ACB8_ATT-US.ffu(在ffu固件压缩包内，解压即可得到) PartitionGuru_Pro (硬盘工具) WPInternals (解锁以及恢复工具) MPRG8974_fh.ede (可以直接在网盘中下载也可以从Lumia救砖合集包中找到) L1520_15035_Denim_zh_CN_V2.1_AoW_TEST (Win10 arm系统及其引导部署工具) 操作刷回Windows Phone 8.1说明：如果你的 NOKIA Lumia1520系统升到了Windows 10 Mobile 那么你需要退回8.1，否则接下来的UEFI解锁将会失败；如果你的手机系统未升级，则可以忽略本步骤 解压WPInternals(以下简称WPI)的压缩包并打开WPInternals.exe 插上数据线并连接手机 在WPI中点击左侧Flash 右侧找到Flash original FFU一栏 看到FFU点击标有下划线的Select the FFU-file to flash to the phone… 选择你下载好的RM940_02540.00019.14484.37028_RETAIL_prod_signed_200_01ACB8_ATT-US.ffu固件 (不知道在哪里的回到文章上方去看) 点击Flash FFU image按钮 读完进度条手机进入系统就算成功了 刷Win10 ArmUEFI解锁 WPI左侧栏中点击Unlock bootloader 如果你的手机没有进入Flash-Mode的话会提示，点击OK按钮 手机显示如下图所示的符号即为进入Flash-Mode 在SecureBoot Unlock V2一栏中按照下图配置(即你之前下好的固件，分别为RM940.ffu / MPRG8974.ede / RM1085.ffu ，目录根据自己储存位置找) 点击Unlock按钮，读条进入大容量模式 出现下图且PC检测到一个名为MainOS的磁盘即为成功 (如果读条卡死或没检测到新磁盘的话，尝试用PartitionGuru_Pro分配一个新盘符) 储存分配 打开PartitionGuru.exe 找到手机硬盘的Data分区 右键，点击 调整分区大小 分区前部的空间 改为12GB，并且选为创建新分区 点击开始按钮，等待读条完毕PC能检测到新的分区即为成功（我这里新分区的盘符为K，接下来都以此为例，你的盘符可能跟我不一样需要记住你本地的盘符） 系统部署 你需要解压 L1520_15035_Denim_zh_CN_V2.1_AoW_TEST.7z 压缩包 得到如下文件 打开WOA32安装脚本.bat 按照其要求(不要输入:)输入你的盘符(就是我们之前创建的那个，我的是k) 输入1，并且等待15~20分钟，读条完毕后按任意键返回菜单 引导搭建 右键 此电脑，选择 管理 -&gt; 磁盘管理，找到手机对应的磁盘(看大小约在14GB左右或看盘符找即可) 选择第一个分区，右键–&gt;更改驱动器号和路径，然后按照下图所示创立一个新的文件夹，其名称为DPP (注意：名称不能错，否则无法启动) 对EFIESP分区重复上述操作，但是新的文件夹命名为EFIESP 回到WOA中输入2，安装引导 提示成功后拔下数据线 进入系统 手机开机进入引导 通过音量下键，选择Windows 10的那项(第四个) 按下相机键确认，等待启动就可以进入Windows10 arm系统了 其他参考文章 IT之家 https://www.ithome.com/0/468/534.htm","link":"/2021/02/04/Lumia1520%CB%A2Windows10%20arm%CB%AB%CF%B5%CD%B3/"},{"title":"Qt开发实战——驾校科目一考试系统","text":"原因最近在学习Qt开发，再加上将要考科目一，于是就来了灵感花了三天时间做了个科目一考试系统作为练习 开发环境 Windows 10 Qt 效果演示1.登陆界面 2.考试界面 程序缺点第一次做Qt还有许多不足之处 登陆信息和题目数据是以本地txt文件的形式保存的，没有射击数据库开发 考试时间仅为计时，没有超时退出考试的功能 不能够连接并从服务器获取数据 界面设计过于简陋 项目开源地址 GitHub 学习内容总结 Qt的信号与槽机制 Qt窗体设计 构造函数的实际用法 Qt布局管理器使用 Qt文件处理方法 元对象系统QObject,QMetaObject ……","link":"/2021/06/24/Qt%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%A9%BE%E6%A0%A1%E7%A7%91%E7%9B%AE%E4%B8%80%E8%80%83%E8%AF%95%E7%B3%BB%E7%BB%9F/"},{"title":"Typecho Handsome主题专用插件UserAgent配置","text":"设置找到Hansome主题component目录下的commens.php文件，大约在该文件第69行左右修改为如下代码 123&lt;span class=&quot;comment-author vcard&quot;&gt;&lt;b class=&quot;fn&quot;&gt;&lt;?php echo $author; ?&gt;&lt;/b&gt;&lt;?php echo $Identity; ?&gt;&lt;?php UserAgent_Plugin::get_useragent($comments-&gt;agent,$comments-&gt;ip); ?&gt;&lt;/span&gt; 然后启用插件即可 详情请参考以下文章 [scode type=”yellow”]https://doge.uk/coding/useragent-modify.html [/scode]","link":"/2020/08/11/Typecho-Handsome%E4%B8%BB%E9%A2%98%E4%B8%93%E7%94%A8%E6%8F%92%E4%BB%B6UserAgent%E9%85%8D%E7%BD%AE/"},{"title":"Search For You自己制作的 一个浏览器导航页","text":"说明最近实在是用腻了国内的一些导航页，edge和chrome的新页标签在我看来不怎么美观，所以就自己动手写了一个。 PC和手机端都做了适配（头一次搞，手机端有些不完美） 使用了二次元随即壁纸API 部分内容在B站上学的 内容如图所示: 地址:https://search.cairbin.top","link":"/2020/05/14/Search-For-You%E8%87%AA%E5%B7%B1%E5%88%B6%E4%BD%9C%E7%9A%84-%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%BC%E8%88%AA%E9%A1%B5/"},{"title":"Typecho博客更改鼠标指针并添加特效","text":"更改指针 控制台–&gt;外观–&gt;设置主题–&gt;自定义CSS，在其中输入以下代码: 12345678910/*下方单引号内输入指针图标的URL*/body { cursor:url(''), auto;}select, input, textarea, a, button { cursor:url(''), auto;}input[disabled], select[disabled], textarea[disabled], input[readonly], select[readonly] { cursor:url(''), auto;} 声明 这部分参考了https://sword.studio/30.html 添加特效 找到主题的footer.php文件，在**前添加如下代码 123456789101112131415161718192021222324252627282930&lt;script type=&quot;text/javascript&quot;&gt; /* 鼠标特效 */var a_idx = 0; jQuery(document).ready(function($) { $(&quot;body&quot;).click(function(e) { var a = new Array(&quot;富强&quot;, &quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;, &quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot; ,&quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;, &quot;诚信&quot;, &quot;友善&quot;); var $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css({ &quot;z-index&quot;: 999999999999999999999999999999999999999999999999999999999999999999999, &quot;top&quot;: y - 20, &quot;left&quot;: x, &quot;position&quot;: &quot;absolute&quot;, &quot;font-weight&quot;: &quot;bold&quot;, &quot;color&quot;: &quot;#ff6651&quot; }); $(&quot;body&quot;).append($i); $i.animate({ &quot;top&quot;: y - 180, &quot;opacity&quot;: 0 }, 1500, function() { $i.remove(); }); }); }); &lt;/script&gt; 声明 添加指针特效部分参考了https://sunpma.com/130.html","link":"/2020/03/15/Typecho%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%94%B9%E9%BC%A0%E6%A0%87%E6%8C%87%E9%92%88%E5%B9%B6%E6%B7%BB%E5%8A%A0%E7%89%B9%E6%95%88/"},{"title":"SayHello","text":"冒个泡证明我还活着（滑稽） 转眼间，我的高三生活已经过去了一两个月了，这段时间一直很忙，所以没写博客。 所以，这篇文章就是用来水的，以表示我还活着（滑稽）","link":"/2020/12/06/SayHello/"},{"title":"Typecho博客邮件回复评论设置","text":"问题我想这是我搭建博客以来遇到的最折腾的问题了，我花了3天时间才解决。一开始我用的是CommentToMail插件的SMTP模式，可是无论我怎么配置，在百度上搜索了一堆方案，都没有解决此问题(猜测与服务器有关)，得到的总会是一个结果:SMTP：Connect() failed 然后，我放弃了使用这个插件，换成LoveKKComment。即使换了插件但依然收不到邮件。我尝试过QQ邮箱，163邮箱的SMTP，都没有成功。经过一段时间摸索，使用阿里云邮件推送 + SMTP + TLS的方式得以解决。如果你也遇到此问题，那么你很幸运不用再花费其他精力去踩坑了，下文会给出解决方案。 插件名称:LoveKKComment https://github.com/ylqjgm/LoveKKComment 解决问题 首先在开通阿里云邮件推送 然后进入控制台按照相关提示操作，不会的话在阿里云邮件推送网站最下方有视频教程，这里不再过多介绍 操作完后设置SMTP密码 回到Typecho的插件管理，设置LoveKKComment插件，注意图中的三点，其余按你在控制台的配置填写 注意：1.SMTP服务器地址要填写正确 2.一定要使用80端口以及该端口对应的TLS加密，其他亲测无效 然后就可以回到评论区进行评论测试，看是否有邮件发送到邮箱内，如果没有的话查看一下垃圾邮件","link":"/2020/03/19/Typecho%E5%8D%9A%E5%AE%A2%E9%82%AE%E4%BB%B6%E5%9B%9E%E5%A4%8D%E8%AF%84%E8%AE%BA%E8%AE%BE%E7%BD%AE/"},{"title":"Typecho设置伪静态","text":"Apache环境 如果是Apache环境的话，需要在根目录创建文件**.htacess**或在宝塔面板添加伪静态，代码如下 123456789101112&lt;IfModule mod_rewrite.c&gt; RewriteEngine On RewriteBase / RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule ^(.*)$ index.php [L,E=PATH_INFO:$1]&lt;/IfModule&gt; Nginx环境 如果是Nginx环境的话需要修改nginx.conf文件或在宝塔面板内添加伪静态 12345location / { if (!-e $request_filename){ rewrite ^(.*)$ /index.php; }} 转换工具 如果你原来已经配置了Apache的伪静态，现在换用了Nginx，则可通过下面方法来转换 转换工具http://winginx.com/en/htaccess","link":"/2020/07/24/Typecho%E8%AE%BE%E7%BD%AE%E4%BC%AA%E9%9D%99%E6%80%81/"},{"title":"Ubuntu18.04安装运行.Net Core","text":"安装添加源1234wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; microsoft.asc.gpgsudo mv microsoft.asc.gpg /etc/apt/trusted.gpg.d/wget -q https://packages.microsoft.com/config/ubuntu/18.04/prod.listsudo mv prod.list /etc/apt/sources.list.d/microsoft-prod.list 安装123sudo apt-get install apt-transport-httpssudo apt-get updatesudo apt-get install dotnet-sdk-3.1 运行 在Win下编译好.Net Core相关文件并上传到Ubuntu 输入以下命令运行12345//运行程序但关闭命令行会停止dotnet **.dll//关闭命令行不会停止nohup dotnet **.dll","link":"/2020/05/04/Ubuntu18.04%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C.Net-Core/"},{"title":"Typecho评论调用QQ头像(转载)","text":"原文作者：旧颜 原文链接：https://jieac.cn/7.html 侵权删 正文 Typecho默认头像来自Gravatar，没设置过头像就丑丑的，想替换为QQ头像。之前用的WordPress，对Typecho不是很熟悉，于是进行百度。 Typecho似乎百度相关资料特别少，唯一能找到的是巷子工坊的两篇文章，但他实现的效果似乎仅支持QQ邮箱，普通邮箱反而不适用。 经过反复测试，最终解决办法如下：修改Typecho目录下的var/Typecho/common.php，在大约1009行，关于获取Gravatar的代码*(转者注：大约在922行)*，修改为： 12345678910111213141516171819202122public static function gravatarUrl($mail, $size, $rating, $default, $isSecure = false) { $reg = &quot;/^\\d{5,11}@[qQ][Qq]\\.(com)$/&quot;; if (preg_match($reg, $mail)) { $img = explode(&quot;@&quot;, $mail); $url = &quot;//q2.qlogo.cn/headimg_dl?dst_uin={$img[0]}&amp;spec=100&quot;; } else { if (defined('__TYPECHO_GRAVATAR_PREFIX__')) { $url = __TYPECHO_GRAVATAR_PREFIX__; } else { $url = $isSecure ? 'https://secure.gravatar.com' : 'http://www.gravatar.com'; $url .= '/avatar/'; } if (!empty($mail)) { $url .= md5(strtolower(trim($mail))); } $url .= '?s=' . $size; $url .= '&amp;amp;r=' . $rating; $url .= '&amp;amp;d=' . $default; } return $url; } PHP 复制* 输入QQ邮箱，调用QQ头像；输入普通邮箱，调用Gravatar头像。 声明 原文作者：旧颜 原文链接：https://jieac.cn/7.html 侵权删","link":"/2020/03/13/Typecho%E8%AF%84%E8%AE%BA%E8%B0%83%E7%94%A8QQ%E5%A4%B4%E5%83%8F(%E8%BD%AC%E8%BD%BD)/"},{"title":"Ubuntu常用命令","text":"帮助 123--help简单的帮助help command 较详细的帮助man command 最详细的帮助 ls 命令 123ls -l 显示较全的文件信息ls --color 显示文件及文件夹，并标有不同的颜色ls -a 显示全部的文件及文件夹 which 用于查找你所执行的命令文件存放的目录 tab键,命令记不全时，输入一部分再按一下进行补全 env当前用户的运行环境。 cmp 用于比较两个文件是否是完全相同的。 cp 用于复制文件 chmod 修改用户对于文件的操作权限 cat 查看ubuntu中文本文件的内容 123cat /proc/cpuinfo 查看cpu信息cat /proc/meminfo 查看内在信息cat /etc/issue 查看ubuntu的版本信息 lsusb 列出计算机里的usb设备 lspci 列出计算机里的pci设备 fdisk 查看硬盘信息 mkdir 创建文件夹,格式:”mkdir 名称” touch 创建文件，可以同时创建多个文件,格式:”touch test1 test2 test3” rm 删除文件,格式:”rm 名称”,-r参数可强制删除","link":"/2020/03/08/Ubuntu%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Ubuntu安装Skype","text":"说明Skype官网为skype.com但在中国大陆会自动跳转到skype.gmw.cnskype.gmw.cn是没有Linux版的安装包的,所以只能去访问其它地区官网来获取下载地址 我现在已经找到了下载地址，所以你可以直接点击下方链接即可获取deb格式的安装包 下载下载链接：https://repo.skype.com/latest/skypeforlinux-64.deb","link":"/2020/04/09/Ubuntu%E5%AE%89%E8%A3%85Skype/"},{"title":"为学校计算机添加一个时钟","text":"起因学校的钟表实在是太菜了，是一个特别小的数码钟表镶嵌在喇叭上，每次看时间都要眯着眼，实在是太难受了，所以我直接写了一个程序放在多媒体计算机上，反正那东西屏幕这么大，不用白不用。 原理主要运用了一个timer控件，没什么技术含量 效果如下 代码这里只提供主窗口的代码,窗口2只写了个退出功能，打算以后加上倒计时和课程表等功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Net.Sockets;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace SchoolClock{ public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void Form1_Load(object sender, EventArgs e) { this.BackColor = Color.White; this.TransparencyKey = Color.White; //托盘 NotifyIcon MyNotifyIcon = new NotifyIcon();//实例化 MyNotifyIcon.Visible = true;//可见性 MyNotifyIcon.Text = &quot;ClockSettings&quot;;//鼠标放在托盘时显示的文字 MyNotifyIcon.BalloonTipText = &quot;ClockSettings&quot;;//气泡显示的文字 MyNotifyIcon.Icon = System.Drawing.Icon.ExtractAssociatedIcon(System.Windows.Forms.Application.ExecutablePath); Icon i = new Icon(&quot;favicon.ico&quot;); MyNotifyIcon.Icon = i; MyNotifyIcon.MouseClick += MyNotifyIcon_MouseDoubleClick; //隐藏 } void MyNotifyIcon_MouseDoubleClick(object sender, MouseEventArgs e) { Form2 f2 = new Form2(); f2.Show(); } private void timer1_Tick(object sender, EventArgs e) { label1.Text = DateTime.Now.ToString(&quot;HH:mm:ss&quot;); label2.Text = DateTime.Now.ToString(&quot;yyyy-MM-dd&quot;); }} 其它好吧，我承认我的确是在水文章，因为开学了时间非常紧张，所以只能抽出很少的一段时间写代码，所以就潦草地写了这个程序。当然，我还会继续完善，只不过要等一段很长的事件。","link":"/2020/06/07/%E4%B8%BA%E5%AD%A6%E6%A0%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%97%B6%E9%92%9F/"},{"title":"Windows提交文件至GitHub(Gitee)仓库","text":"介绍&amp;准备介绍本文章只是介绍最基本的用法图片来自网络 准备 一台装有Windows的计算机(系统Win7以上，最好是Win10) Git TortoiseGit(绰号“小乌龟”) 安装软件安装Git 去官网下载Git，根据你的系统选择32位还是64位 官网:https://git-scm.com/下载:https://git-scm.com/download/win 进行安装，不懂的话，一切按默认进行即可 安装TortoiseGit(小乌龟) 下载TortoiseGit，还是根据系统选择32位还是64位 官网:https://download.tortoisegit.org/下载:https://download.tortoisegit.org/tgit/ 安装Tortoise，不懂的话默认即可，但其中有两步需要注意 这一步可以选择语言，但我推荐使用英文，因为很多项目开发都是英文环境，要学会适应。(中文需额外下载) 这里输入你的邮箱和用户名，尽量和GitHub(Gitee)一致(注:该配置可在 C盘-&gt;用户-&gt;”你的用户名”-&gt;.gitconfig文件修改，该文件可能被隐藏) 然后继续下去直至安装完毕即可 创建仓库 在你的GitHub或Gitee创建仓库，并设置为Public(公开) 来到仓库界面-&gt;Clone(克隆)-&gt;复制HTTPS地址 使用 在本地创建一个文件夹，来存放仓库 在该目录下，右键-&gt;Git Clone-&gt;复制链接到URL框内(该操作可能自动完成)-&gt;点击OK 然后会生成一个文件夹，进入，将你想要上传的文件或非空目录放进去。(该文件夹内的.git目录是自动生成，请勿删除) 右键-&gt;Git Commit 在Message填写信息(必须填写，否则无法提交)，在Check框选择要提交的文件，最后点击Commit 读取进度条完成后，会有蓝色Success字样,这说明提交到本地缓冲，但没提交到GitHub(Gitee) 此时你必须点击Push(可能会让你输入账号密码)才能上传成功，若选择了Close则可以 右键-&gt;TortoiseGit-&gt;Push 完成推送上传 报错如果报错或提交其他仓库没有要求输入账号密码，则可能是缓存问题在CMD中输入以下命令，然后重新提交就可以了 1git credential-manager uninstall","link":"/2020/04/10/Windows%E6%8F%90%E4%BA%A4%E6%96%87%E4%BB%B6%E8%87%B3GitHub(Gitee)%E4%BB%93%E5%BA%93/"},{"title":"Windows下Java安装与环境变量配置","text":"前言本文章以Win10较新版本为例，Win7及其以后的windows版本类似 步骤下载 第一步自然是去官网下载Java了 点击 “免费 Java 下载” 按钮 跳转到 “下载适用于 Windows 的 Java”的界面 点击“同意并开始免费下载按钮”，然后就会得到JavaSetup.exe文件 安装 点击刚才得到的文件 按照提示安装即可（记住你的安装路径，后面配置要用到） 环境变量什么是环境变量“环境变量（environment variables）”一般是指在操作系统中用来指定操作系统运行环境的一些参数 配置Java环境变量 安装完成后，右击”此电脑“，点击”属性“，选择”高级系统设置“ 这里可能会提示“以管理员的身份运行”，我们要选择的“是”（没弹窗的话就不用管了） 然后就会弹出“系统属性”窗口 选择“高级”，点击“环境变量” 会弹出“环境变量”窗口；找到“系统变量”一栏 点击“新建”，变量名和变量值(你的安装路径)如下所示填写，然后点击“确定” 12345//变量名Java_Home//变量值， 此处只是举例，实际路径为你之前安装的路径C:\\Program Files\\Java\\jdk1.8.0_91 再点击“新建”，变量名和变量值如下所示填写，然后点击“确定”（如果有CLASSPATH就“编辑”） 12345//变量名CLASSPATH//变量值.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; 在“系统变量”（不是用户变量！！）中找到“Path”点击”编辑“ 此处往下步骤新版本win10与旧版本windows(旧win10,win7/8/8.1)略有不同，以新版win10为例，旧版本可参考菜鸟教程 在”编辑环境变量“窗口下，点击“新建”，填写内容如下，然后点击“确定” 123//新建两行分别填写%Java_Home%\\bin%Java_Home%\\jre\\bin 依次保存并返回即可 检验 按下 ”Win + R“键，输入”cmd“ 在cmd中，输入”java -version” 有版本号输出即为成功","link":"/2020/08/16/Windows%E4%B8%8BJava%E5%AE%89%E8%A3%85%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"},{"title":"使用Visual Studio 2019开发Qt程序","text":"安装Qt 如标题，你首先需要到 http://download.qt.io/ 去下载并安装Qt，并在引导下安装MSVC组件（这里不做过多解释） Visual Studio 2019 配置 打开VS2019 点击“继续但无需代码” “扩展(X)” -&gt; “管理扩展” 搜索“Qt” 找到“Qt Visual Studio Tools”,点击“下载”按钮（图中是已经安装好的所以不显示下载） 安装过程中会弹出 VSIX Installer窗口，依据引导安装即可 检查 当我们再次打开 Visual Studio 2019 -&gt; “创建新项目” -&gt; 搜索“Qt”,发现已经能够创建Qt项目了 但是这还没有完，因为我们还没有添加 Qt Version 添加 Qt Version 点击“上一步” -&gt; “继续但无需代码” -&gt; “扩展(X)” -&gt; “Qt VS Tools” -&gt; “Qt Versions” 点击“add new Qt version”,然后点击Path列下的类似于文件夹的图标 找到你的Qt安装目录，在里面找MSVC的 qmake.exe (例如我的的Qt安装在D盘根目录，Qt版本是5.14.2，那么对应的就应该为 D:\\Qt\\Qt5.14.2\\5.14.2\\msvc2017_64\\bin\\qmake.exe) 最后点击“确定”按钮保存即可 注：图片中第一行显示的版本是我之前已经配置好的Qt版本，如果你是第一次配置，是不会自动添加Qt版本的","link":"/2021/07/17/%E4%BD%BF%E7%94%A8Visual%20Studio%202019%E5%BC%80%E5%8F%91Qt%E7%A8%8B%E5%BA%8F/"},{"title":"算法题——Cantor表","text":"题目介绍描述现代数学的著名证明之一是 Georg Cantor 证明了有理数是可枚举的。他是用下面这一张表来证明这一命题的： 1/1, 1/2 , 1/3, 1/4, 1/5, … 2/1, 2/2, 2/3, 2/4, … 3/1, 3/2, 3/3, … 4/1, 4/2, … 5/1, … … 我们以Z字形给表上每一项编号。第一项是1/1,然后是1/2, 2/1, 3/1, 2/2, … 输入格式整数N(1&lt;= N &lt;=10^7) 输出格式表中的第N项 样例输入： 17 输出: 11/4 分析规律我们通过题目可知，在Cantor表中走法为Z字形 不妨将Cantor表转化为下图 即 从左往右数 奇数行分母依次递增，分子依次递减 偶数行分母依次递减，分子依次递增 可知奇偶数行分子分母规律正好相反 所以为使奇偶数行变化规律一致并且符合题中所给的项数规律，我们可以规定 在上图中，奇数行从左往右数，偶数行从右往左数 找查例如我们要找查第7项，前三行一共有6项，前4行一共有10项 很显然 6 &lt; 7 &lt; 10 所以我们可以很方便地确定第7项在第4行中 又 前几行项数 - 所要找的项数 = 所要找的项所在行的最后一项分子 - 所找项分子 同理 前几行项数 - 所要找的项数 = 所找项分母 - 所找项所在行最后一项分母 这两个等式中我们分别知道任意三个量就可以求其中的第四个量 然后，我们继续根据规律确定第7项的具体的值为 1/4 最后，我们可以轻易得出求任意项的算法如下 解法以下是笔者的解题方法 先上代码 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main(){ int n = 0, sum = 0, i = 1; cin &gt;&gt; n; while(sum &lt; n) { ++i; //这里一定要让i先自增再求和，否则求出来的和少一项（此处的项指的是等差数列的项） sum = i*(i - 1)/2; //首项公差均为1的等差数列求和，此处的和为第i行为止的Cantor表的总项数 } //总项数与所找项的项数的差 int dif = sum - n; if((i - 1) % 2 != 0) //如果i-1行为奇数，那么i行为偶数行，偶数行从右开始数（这里在写的时候绕了个弯） cout &lt;&lt; 1 + dif &lt;&lt; &quot;/&quot; &lt;&lt; i - 1 - dif; else //第i行为奇数行，从左边数 cout &lt;&lt; i - 1 -dif &lt;&lt; &quot;/&quot; &lt;&lt; 1 + dif; }","link":"/2021/09/03/cantor%E8%A1%A8/"},{"title":"关于提问与伸手党的那些事","text":"个人早期经历在我还是个小白什么也不懂的时候，我也做过伸手党，很自然地被一群大佬驳回了。因此，本文并无贬低新手之意，相信每个人在面对自己不懂的事物的时候都有这样的一个过程，只是就事论事，为更多像曾经的我那样的人提供一些个人经验。 其他经历后来随着懂得的知识越来越多，自然而然地学会了如何去提问和独立解决问题。在这个过程中，也同样使得身边的人知道了我有某方面的一些经验，尽管这些经验微不足道。前一段时间，疫情爆发，我们统一在家里上网课。我们学校采用的软件是有一堆Bug的智学网（智障网），并不是那个分期付款给五星好评的钉钉。这就使得我们被迫自愿地去下载软件。于是有趣的事情就诞生了（滑稽）。有个同学想要用电脑听课，于是在一个乌七八糟的网站上下载PC版智学网客户端，却安装了好几款流氓软件。先不吐槽下载软件不去官网的操作，就智学网而言，是没有PC客户端的，只有web版（虽然web版会强制你去下载手机客户端）。然后，那个人向我求助，并给我说：“我软件明明卸载了，但还是在右下角弹广告。”。我好奇问他怎么卸载的，他的操作让我傻了眼——“删除快捷方式”。到这里，应该就能猜到发生了什么了。那个人跳过了问问题直接让我QQ远程桌面帮他卸载程序。。。不过看在同学的份上并没有再说什么，让我感到惨的是我笔记本的系统是deepin，利用deepin-wine运行QQ远程桌面会有bug。最后通过Teamviewer折腾了半天才卸载了流氓软件。从上述事件，我认为他只需要百度一下就能学会从windows上安装和卸载应用程序，只不过面对自己不懂的东西，选择了懒惰做了伸手党。我心想总这样下去不是办法，我还要留出时间解决自己的问题和学习（滑稽），于是我写了这篇文章，并会在下方给出一张思维导图和链接，当又有人做伸手党的时候，可以将本文或图片等丢给他们。希望大家都能去不断探索，学会自己独立思考，提高自我学习能力，总之还是那句话：生命不息，折腾不止！ 正确提问，杜绝伸手党思维导图(https://cairbin.top/pic/askquestion.png) 链接 (友链大佬 摩尔 制作，专治伸手党) 让我来帮你百度一下https://baidu.mole9630.top/ https://www.baidu.com ** 推荐文章 ** 作者：摩尔の镇文章：学会怎么去提问 ** 本文链接 ** 作者：CairBin题目：关于提问与伸手党的那些事链接：https://cairbin.top/archives/35/","link":"/2020/03/28/%E5%85%B3%E4%BA%8E%E6%8F%90%E9%97%AE%E4%B8%8E%E4%BC%B8%E6%89%8B%E5%85%9A%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"},{"title":"冒泡排序","text":"代码123456789101112131415161718192021222324/** 冒泡排序* 参数: 参与排序的数组， 数组元素个数*/void BubbleSort(int R[], int n){ int i, j; bool flag; for(i = n-1; i&gt;=1; i--) { flag = false; //用于标记本次循环是否发生交换 for(j=1; j&lt;=i; j++) if(R[j-1]&gt;R[j]) { //交换 R[j] ^= R[j-1] ^= R[j] ^= R[j-1]; flag = true; } if(!flag) return; } } 原理冒泡排序是通过一系列交换操作完成的。首先比较第一个数字与第二个数字，若第一个大则交换；然后比较第二个和第三个数字，若第二个大，则交换;之后再比较前三个数字，进行排序；依次类推 冒泡排序的结束标志是在一趟排序的过程中没有交换 即在一次对该数组遍历中没有发生数字交换，等同于R[j-1] &lt;= R[j]恒成立，由不等式的传递性可知，该序列有序，所以无需排序，执行return","link":"/2021/10/17/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"title":"双链表的操作","text":"双链表的代码定义1234567891011#include &lt;iostream&gt;using namespace std;typedef struct _DLNode{ int data; //结点数据域 struct _DLNode *next; //指向后继的指针 struct _DLNode *prev; //指向前驱的指针 }DbLinkNode,DbLinkList; 双链表的操作初始化双链表1234567891011121314//初始化双链表bool initDbLinkList(DbLinkList* &amp;L){ L = new DbLinkNode; //合法性检查，检查内存是否分配成功 if(!L) return false; L-&gt;next = NULL; L-&gt;prev = NULL; L-&gt;data = -1; return true;} 插入前插法123456789101112131415161718192021222324252627282930//前插法bool DbListInsertFront(DbLinkList* &amp;L, DbLinkNode *node){ //合法性检查 if(!L || !node) return false; // if(L-&gt;next == NULL)// {// //若只有头结点，则在头结点后面插入一个结点// node-&gt;next = NULL;// node-&gt;prev = L;// L-&gt;next = node;// }// else// {// //若有多个结点，则在头结点与其后结点之间插入// L-&gt;next-&gt;prev = node; //令第二结点指向前驱的指针指向node// node-&gt;next = L-&gt;next;// node-&gt;prev = L;// L-&gt;next = node;// } //优化 if(L-&gt;next) L-&gt;next-&gt;prev = node; node-&gt;next = L-&gt;next; node-&gt;prev = L; L-&gt;next = node; return true;} 尾插法1234567891011121314151617181920//尾插法bool DbListInsertBack(DbLinkList* &amp;L, DbLinkNode *node){ //合法性检查 if(!L || !node) return false; DbLinkNode *p = L; //找到尾结点 while(p-&gt;next) { p = p-&gt;next; } node-&gt;next = NULL; node-&gt;prev = p; p-&gt;next = node; return true;} 任意位置插入1234567891011121314151617181920212223242526272829303132333435363738//任意位置插入/* 参数: 插入的双向链表， 插入位置， 插入结点数据域的值*/bool DbListInsert(DbLinkList* &amp;L, int i, int &amp;e){ //若链表为空未初始化，返回false if(!L) return false; //若只有头结点，但插入位置不等于1，则返回false if((!L-&gt;next &amp;&amp; i != 1) || i &lt; 1) return false; int j = 0; DbLinkList *p = L, *s; while(p &amp;&amp; j &lt; i) { //找查位置为i的结点 p = p-&gt;next; j++; } if(!p || j != i) { cout &lt;&lt; &quot;不存在结点&quot; &lt;&lt; i &lt;&lt; endl; return false; } cout &lt;&lt; &quot;p: &quot; &lt;&lt; p &lt;&lt; endl; s = new DbLinkNode; //生成新的结点 s-&gt;data = e; s-&gt;next = p; s-&gt;prev = p-&gt;prev; p-&gt;prev-&gt;next = s; p-&gt;prev = s; return true;} 双链表的遍历输出123456789101112131415161718192021//双向链表的遍历输出void printDbList(DbLinkList *L){ //检查链表是否为空 if(!L) { cout &lt;&lt; &quot;链表为空&quot; &lt;&lt; endl; return; } DbLinkList *p = L; p = p-&gt;next; while(p) { cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = p-&gt;next; } } 元素删除与双链表的销毁本部分操作与单链表一致，请参考《单链表的操作》","link":"/2021/09/28/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/"},{"title":"单链表的操作","text":"单链表代码定义12345typedef struct LinkNode{ int data; //data存放结点的数据域（以int类型为例） struct LinkNode *next; //结点的指针域}LinkNode, LinkList; 单链表的操作初始化单链表123456789bool initList(LinkList* &amp;L) //L类型为引用类型的指针{ L = new LinkNode; //为L分配一个动态内存 if(!L) return false; //若分配失败则返回false //头结点指针指向空完成初始化，成功创建一个空的单链表并返回true L-&gt;next = NULL; return true;} 插入结点注： L为插入的单链表，node为将要插入的结点 前插法12345678bool ListInsert_front(LinkList* &amp;L, LinkNode *node){ //合法性检查 if(!L || !node) return false; node-&gt;next = L-&gt;next; //把新结点指针指向原来头结点所指向的结点 L-&gt;next = node; //把头结点指向新结点} 尾插法12345678910111213141516bool ListInsert_back(LinkList* &amp;L, LinkList *node){ LinkNode *last = NULL; if(!L || !node) return false; last = L; //找到尾结点 while(last-&gt;next) last = last-&gt;next; //重置指针 node-&gt;next = NULL; last-&gt;next = node; return true;} 任意位置插入123456789101112131415161718192021222324252627282930313233343536//任意位置插入/* * 参数： 要插入的单链表， 位置， 取值 */bool LinkInsert(LinkList* &amp;L, int i, int &amp;e){ if(!L) return false; int j = 0; LinkList *p, *s; p = L; //让p寻找插入位置 while(p &amp;&amp; j&lt;i-1) { p = p-&gt;next; j++; } //如果插入位置大于链表节点数，最后p为空 //有一种情况为：若i &lt;= 0 ,j&lt;i-1不成立，但此时p为真，所以这里使用 !p || j&gt;i-1 if(!p || j&gt;i-1) { return false; } //当i = 0时，p为真且 j = i - 1， 此时指向头结点，直接来到下方这一步 s = new LinkNode; //生成新结点 //连接结点 s-&gt;data = e; //保存数据 s-&gt;next = p-&gt;next; p-&gt;next = s; return true;} 输出单链表中的元素123456789101112131415161718void LinkPrint(LinkList* &amp;L){ LNode *p = NULL; if(!L) { cout &lt;&lt; &quot;此链表为空\\n&quot;; return; } p = L-&gt;next; while(p) { cout &lt;&lt; p-&gt;data &lt;&lt; &quot;\\t&quot;; p = p-&gt;next; } cout &lt;&lt; endl;} 元素找查按位置查找与任意位置插入类似，只不过要注意访问头结点的情况（带头结点的单链表头结点数据域无初始化数据） 123456789101112131415161718192021222324252627/* * 参数： 单链表， 位置， 取值 */bool GetLinkListElemAsAddress(LinkList* &amp;L, int i, int &amp;e){ if(!L || !L-&gt;next) return false; int j = 0; LinkList *p; p = L; while(p &amp;&amp; j &lt; i-1) { p = p-&gt;next; j++; } if(!p || j &gt;= i - 1) //这里取等号是为了避免访问头结点数据 { return false; } e = p-&gt;data; return true;} 按值查找1234567891011121314151617181920212223242526272829/** 带头结点的单链表L中找查值为e的元素* 参数：单链表， 取值, 返回所找元素的位置*/bool GetLinkListElemAsValue(LinkList *L, int e, int &amp;index){ LinkList *p; p = L-&gt;next; index = 1; if(!L || !L-&gt;next) { index = 0; return false; } while(p &amp;&amp; p-&gt;data! = e) { p = p-&gt;next; index++; } if(!p) { index = 0; return false; //查无此值 } return true;} 结点的删除1234567891011121314151617181920212223242526272829bool LinkListDel(LinkList* &amp;L, int i){ LinkList *p, *q; int index = 0; p = L; //合法性检查 if(!L || !L-&gt;next) { return false; } while((p-&gt;next) &amp;&amp; (index &lt; i-1)) { p = p-&gt;next; index++; } //删除位置不合理 if(!p-&gt;next || (index &gt; i - 1)) { return false; } q = p-&gt;next; //临时存放被删结点地址 p-&gt;next = q-&gt;next;//改变删除结点前驱指针域 delete q; return true; } 单链表的销毁分配动态内存后，记得销毁 12345678910111213141516void LinkDestory(LinkList* &amp;L){ //定义临时结点指向头结点 LinkList *p = L; cout &lt;&lt; &quot;销毁链表&quot; &lt;&lt; endl; //遍历并删除结点 while(p) { L = L-&gt;next; delete p; p = L; } }","link":"/2021/09/12/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"title":"向因新冠病毒牺牲者表示哀悼","text":"内容[scode type=”share”]国务院今天发布公告，决定2020年4月4日举行全国性哀悼活动。在此期间，全国和驻外使领馆下半旗志哀，全国停止公共娱乐活动。4月4日10时起，全国人民默哀3分钟，汽车、火车、舰船鸣笛，防空警报鸣响。[/scode] 这次新型冠状病毒突然来袭，无论是烈士们还是感染病毒而逝世的人，都应该被铭记。 抗击肺炎不只是个人、国家的事，更是全人类全世界的大事。那些烈士们是以自己的生命为代价守护全人类、全世界。 有的人认为与自己无关沉迷娱乐，有的人做了最美逆行者，为守护他人而献出生命。 在此，向牺牲者表示哀悼，向生存者表示慰问。","link":"/2020/04/04/%E5%90%91%E5%9B%A0%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92%E7%89%BA%E7%89%B2%E8%80%85%E8%A1%A8%E7%A4%BA%E5%93%80%E6%82%BC/"},{"title":"基于JS实现回到页面顶部的五种写法(从实现到增强)【转】","text":"写法【1】 描点 使用锚点链接是一种简单的返回顶部的功能实现。该实现主要在页面顶部放置一个指定名称的锚点链接，然后在页面下方放置一个返回到该锚点的链接，用户点击该链接即可返回到该锚点所在的顶部位置 1234&lt;body style=&quot;height:2000px;&quot;&gt;&lt;div id=&quot;topAnchor&quot;&gt;&lt;/div&gt;&lt;a href=&quot;#topAnchor&quot; style=&quot;position:fixed;right:0;bottom:0&quot;&gt;回到顶部&lt;/a&gt;&lt;/body&gt; 【2】 scrollTopcrollTop属性表示被隐藏在内容区域上方的像素数。元素未滚动时，scrollTop的值为0，如果元素被垂直滚动了，scrollTop的值大于0，且表示元素上方不可见内容的像素宽度由于scrollTop是可写的，可以利用scrollTop来实现回到顶部的功能 12345678&lt;body style=&quot;height:2000px;&quot;&gt;&lt;button id=&quot;test&quot; style=&quot;position:fixed;right:0;bottom:0&quot;&gt;回到顶部&lt;/button&gt;&lt;script&gt;test.onclick = function(){document.body.scrollTop = document.documentElement.scrollTop = 0;}&lt;/script&gt;&lt;/body&gt; 【3】scrollTo() scrollTo(x,y)方法滚动当前window中显示的文档，让文档中由坐标x和y指定的点位于显示区域的左上角设置scrollTo(0,0)可以实现回到顶部的效果 12345678&lt;body style=&quot;height:2000px;&quot;&gt;&lt;button id=&quot;test&quot; style=&quot;position:fixed;right:0;bottom:0&quot;&gt;回到顶部&lt;/button&gt;&lt;script&gt;test.onclick = function(){scrollTo(0,0);}&lt;/script&gt;&lt;/body&gt; 【4】scrollBy() scrollBy(x,y)方法滚动当前window中显示的文档，x和y指定滚动的相对量只要把当前页面的滚动长度作为参数，逆向滚动，则可以实现回到顶部的效果 123456789&lt;body style=&quot;height:2000px;&quot;&gt;&lt;button id=&quot;test&quot; style=&quot;position:fixed;right:0;bottom:0&quot;&gt;回到顶部&lt;/button&gt;&lt;script&gt;test.onclick = function(){var top = document.body.scrollTop || document.documentElement.scrollTopscrollBy(0,-top);}&lt;/script&gt;&lt;/body&gt; 【5】scrollIntoView()Element.scrollIntoView方法滚动当前元素，进入浏览器的可见区域 该方法可以接受一个布尔值作为参数。如果为true，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为false，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为true 使用该方法的原理与使用锚点的原理类似，在页面最上方设置目标元素，当页面滚动时，目标元素被滚动到页面区域以外，点击回到顶部按钮，使目标元素重新回到原来位置，则达到预期效果 123456789&lt;body style=&quot;height:2000px;&quot;&gt;&lt;div id=&quot;target&quot;&gt;&lt;/div&gt;&lt;button id=&quot;test&quot; style=&quot;position:fixed;right:0;bottom:0&quot;&gt;回到顶部&lt;/button&gt;&lt;script&gt;test.onclick = function(){target.scrollIntoView();}&lt;/script&gt;&lt;/body&gt; ##增强## 下面对回到顶部的功能进行增强 【1】显示增强 使用CSS画图，将“回到顶部”变成可视化的图形(如果兼容IE8-浏览器，则用图片代替) 使用CSS伪元素及伪类hover效果，当鼠标移动到该元素上时，显示回到顶部的文字，移出时不显示 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style&gt;.box{position:fixed;right:10px;bottom: 10px;height:30px;width: 50px; text-align:center;padding-top:20px; background-color: lightblue;border-radius: 20%;overflow: hidden;}.box:hover:before{top:50%}.box:hover .box-in{visibility: hidden;}.box:before{position: absolute;top: -50%;left: 50%;transform: translate(-50%,-50%);content:'回到顶部';width: 40px;color:peru;font-weight:bold;} .box-in{visibility: visible;display:inline-block;height:20px;width: 20px;border: 3px solid black;border-color: white transparent transparent white;transform:rotate(45deg);}&lt;/style&gt;&lt;body style=&quot;height:2000px;&quot;&gt;&lt;div id=&quot;box&quot; class=&quot;box&quot;&gt;&lt;div class=&quot;box-in&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;/body&gt; 【2】动画增强 为回到顶部增加动画效果，滚动条以一定的速度回滚到顶部 动画有两种：一种是CSS动画，需要有样式变化配合transition；一种是javascript动画，使用定时器来实现 在上面的5种实现中，scrollTop、scrollTo()和scrollBy()方法可以增加动画，且由于无样式变化，只能增加javascript动画 定时器又有setInterval、setTimeout和requestAnimationFrame这三种可以使用，下面使用性能最好的定时器requestAnimationFrame来实现 [scode type=”yeallow[scode type=”red”] [注意]IE9-浏览器不支持该方法，可以使用setTimeout来兼容 [/scode] 增加scrollTop的动画效果 123456789101112131415&lt;script&gt;var timer = null;box.onclick = function(){cancelAnimationFrame(timer);timer = requestAnimationFrame(function fn(){var oTop = document.body.scrollTop || document.documentElement.scrollTop;if(oTop &gt; 0){document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;timer = requestAnimationFrame(fn);}else{cancelAnimationFrame(timer);} });}&lt;/script&gt; 增加scrollTo()动画效果将scrollTo(x,y)中的y参数通过scrollTop值获取，每次减少50，直到减少到0，则动画完毕 123456789101112131415&lt;script&gt;var timer = null;box.onclick = function(){cancelAnimationFrame(timer);timer = requestAnimationFrame(function fn(){var oTop = document.body.scrollTop || document.documentElement.scrollTop;if(oTop &gt; 0){scrollTo(0,oTop-50);timer = requestAnimationFrame(fn);}else{cancelAnimationFrame(timer);} });}&lt;/script&gt; 增加scrollBy()动画效果将scrollBy(x,y)中的y参数设置为-50，直到scrollTop为0，则回滚停止 123456789101112131415&lt;script&gt;var timer = null;box.onclick = function(){cancelAnimationFrame(timer);timer = requestAnimationFrame(function fn(){var oTop = document.body.scrollTop || document.documentElement.scrollTop;if(oTop &gt; 0){scrollBy(0,-50);timer = requestAnimationFrame(fn);}else{cancelAnimationFrame(timer);} });}&lt;/script&gt; ##实现##由于scrollTop、scrollBy()和scrollTo()方法，都以scrollTop值是否减少为0作为动画停止的参照，且三个动画的原理和实现都基本相似，性能也相似。最终，以最常用的scrollTop属性实现动画增强效果 当然，如果觉得50的速度不合适，可以根据实际情况进行调整 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;style&gt;.box{position:fixed;right:10px;bottom: 10px;height:30px;width: 50px; text-align:center;padding-top:20px; background-color: lightblue;border-radius: 20%;overflow: hidden;}.box:hover:before{top:50%}.box:hover .box-in{visibility: hidden;}.box:before{position: absolute;top: -50%;left: 50%;transform: translate(-50%,-50%);content:'回到顶部';width: 40px;color:peru;font-weight:bold;} .box-in{visibility: visible;display:inline-block;height:20px;width: 20px;border: 3px solid black;border-color: white transparent transparent white;transform:rotate(45deg);}&lt;/style&gt;&lt;body style=&quot;height:2000px;&quot;&gt;&lt;div id=&quot;box&quot; class=&quot;box&quot;&gt;&lt;div class=&quot;box-in&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;script&gt;var timer = null;box.onclick = function(){cancelAnimationFrame(timer);timer = requestAnimationFrame(function fn(){var oTop = document.body.scrollTop || document.documentElement.scrollTop;if(oTop &gt; 0){document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;timer = requestAnimationFrame(fn);}else{cancelAnimationFrame(timer);} });}&lt;/script&gt; 原文地址原文地址：https://www.jb51.net/article/91824.htm","link":"/2020/08/20/%5B%E8%BD%AC%5D%E5%9F%BA%E4%BA%8EJS%E5%AE%9E%E7%8E%B0%E5%9B%9E%E5%88%B0%E9%A1%B5%E9%9D%A2%E9%A1%B6%E9%83%A8%E7%9A%84%E4%BA%94%E7%A7%8D%E5%86%99%E6%B3%95(%E4%BB%8E%E5%AE%9E%E7%8E%B0%E5%88%B0%E5%A2%9E%E5%BC%BA)/"},{"title":"如何更新Typecho","text":"前言更新了handsome主题后也打算把Typecho更新下，现在Typecho版本已经到了1.1正式版本了。 方法Typecho更新不需要将文件全部删除（不需要！不需要！不需要！ 看清楚) 去官网下载Typecho1.1正式版 在你的主机或服务器上找到旧版本Typecho目录 删除其中的admin文件夹、var文件夹、index.php 上传新的admin文件夹、var文件夹、index.php 然后回到typecho后台就会发现版本已经更新了","link":"/2020/08/15/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0Typecho/"},{"title":"学习笔记《数据结构与算法分析-C语言描述》—表栈和队列","text":"抽象数据类型 抽象数据类型(ADT)是一些操作的集合，是数学的抽象。对于集合ADT，可以有诸如并、交、测定大小以及取余等操作。或者，我们也可以只要两种操作：并和找查，这两种操作又在该集合上定义了一种不同的ADT。","link":"/2020/08/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-C%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E3%80%8B%E2%80%94%E8%A1%A8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"title":"安装一台黑苹果","text":"准备配置 主板：磐正ib85my-q7 CPU：Inter i3-4170 3.7GHZ 显卡：RX580(千万别用2048sp的，否则不识别还要刷Bios) 内存：至少4G 硬盘：KingDian 120G固态 工具 Etcher Diskgenius 系统镜像：黑果小兵Catalina10.15.4 安装制作U盘 使用Etcher和镜像制作启动盘，不会自行百度 用Diskgenius在其esp分区EFI/CLOVER/drivers/UEFI/目录下AptioMmoryFix.efi文件删除 将esp分区EFI/CLOVER/drivers/off的OsxAptionFix3Drv.efi复制到EFI/CLOVER/drivers/UEFI/目录中（不替换文件的话，在安装系统过程中会剩余两分钟时卡死并重启） 硬盘设置使用Diskgenius将固态硬盘格式设置为FAT32 Bios设置 重启进入bios 在 Advanced-&gt;SATA Configuration找到安装盘并将Hot Plug属性设置为 Disabled 保存并退出 U盘启动 找到U盘进入，并选择安装mac（默认config文件即可） 等待跑完代码（报错自行百度） 磁盘工具抹掉安装盘并设为Mac日志式（HFS+）格式 退出磁盘工具，进入“安装MacOS” 选择安装盘，然后同意一些协议并安装 安装快完成时会重启，然后同样进入引导，默认Install MacOS from MAC（不用管它就行，会自动） 进入系统 最后会再自动重启然后进入系统 进行系统设置 进入系统 在设置中禁止睡眠 然后配置驱动（这里最麻烦，最好根据自己情况自行搜索）","link":"/2020/04/13/%E5%AE%89%E8%A3%85%E4%B8%80%E5%8F%B0%E9%BB%91%E8%8B%B9%E6%9E%9C/"},{"title":"实验室制取乙酸乙酯","text":"实验原理化学方程式: C2H5OH + CH3COOH &lt;=浓硫酸,Δ=&gt; CH3COOC2H5 + H2O (可逆号)操作步骤:事先加入碎瓷片，然后先加浓硫酸，再加乙醇，再加冰醋酸，密度先小后大，然后加热，将蒸汽通入盛有饱和Na2CO3溶液的试管或锥形瓶 成分及其作用 浓硫酸：作为吸水剂和催化剂 碎瓷片：防止暴沸 饱和Na2CO3溶液：减小乙酸乙酯溶解度；与蒸出的乙酸反应；溶解蒸发出的乙醇 注意事项 该反应为可逆反应. 制备温度应该控制在60~70℃,液体加热至沸腾应该用小火加热,温度过高会有亚硫酸和乙醚等产物产生. 要事先加入碎瓷片防止暴沸. 导气管不要伸入饱和Na2CO3溶液以下，防止倒吸. 浓硫酸具有强氧化性，谨慎使用. 视频暂未上传","link":"/2020/03/07/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%88%B6%E5%8F%96%E4%B9%99%E9%85%B8%E4%B9%99%E9%85%AF/"},{"title":"如何防止网站被恶意解析","text":"经历 今天我在百度上搜索我博客的名字，发现有两个除了域名以外完全一样的网站，ping之后IP地址一模一样，我立马意识到网站被恶意解析了。 什么是恶意解析 恶意解析就是别人的域名的A记录填写你的服务器IP地址，对于原本网站的流量和SEO等有影响。 Nginx解决方案 通过宝塔面板设置一个不用的默认站点，即所有未在面板绑定的域名都会访问到这个默认站点 在该站点的设置下修改配置文件（不是配置文档） 123456server{ listen 80 default_server; listen 443; server_name *.*.*.*; return 444; (注意：server_name后面是你服务器的IP地址，return 444;后面还有原本的内容，这里忽略了) 3.然后你就打开恶意解析的那个域名，发现已经提示无法访问了","link":"/2020/07/24/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E7%BD%91%E7%AB%99%E8%A2%AB%E6%81%B6%E6%84%8F%E8%A7%A3%E6%9E%90/"},{"title":"循环链表定义及操作","text":"循环链表定义定义与单链表一样，操作时将末结点的指针指向开始结点即可 12345typedef struct _LinkNode{ int data; struct _LinkNode *next;}LinkList; 循环链表操作初始化循环链表1234567891011bool InitList(LinkList* &amp;L){ L = new LinkList; if(!L) return false; L-&gt;next = L; L-&gt;data = 0; //往头结点塞个数据，这时候严格来讲为无头结点循环链表，第一个结点应该叫开始结点 return true;} 插入（尾插）123456789101112131415161718192021222324bool ListInsert_back(LinkList* &amp;L, LinkList *node){ LinkList *last = NULL; if(!L || !node) return false; if(L == L-&gt;next) { //头结点指针指向了自己（链表只有头结点） node-&gt;next = L; L-&gt;next = node; }else{ //非空的循环链表 last = L-&gt;next; //寻找尾结点（指向头结点的结点） while(last-&gt;next != L) { last = last-&gt;next; } node-&gt;next = L; last-&gt;next = node; } return true;} 输出数据123456789101112131415161718192021void LinkListPrint(LinkList *L){ LinkList *p; if(!L || L == L-&gt;next) { cout &lt;&lt; &quot;链表为空\\n&quot;; return; } p = L-&gt;next; while(p != L) { cout &lt;&lt; p-&gt;data &lt;&lt; &quot;\\t&quot;; p = p-&gt;next; } cout &lt;&lt; endl;}","link":"/2021/09/18/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%93%8D%E4%BD%9C/"},{"title":"推荐一个数学绘图软件GeoGebra","text":"内容作为一名数学爱好者，强大的的绘图软件是必不可少的。这里我推荐一款我特别喜欢的软件GeoGebra。具体功能我就不细说了，只有用起来才能体会它的强大。** 最重要的是它支持Win Mac Linux三大平台！！！！ ** 然后附上链接地址： 官网：https://www.geogebra.org/","link":"/2020/04/07/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%A6%E7%BB%98%E5%9B%BE%E8%BD%AF%E4%BB%B6GeoGebra/"},{"title":"小天才XTC Z1S开启ADB","text":"起因最近入手了Apple Watch，但因系统闭源和国区App Store第三方应用实在是少，所以就开始折腾起安卓表来了。正好家里有块给小孩子用的小天才手表，所以就想到了通过ADB调试安装一些这块表原本没有的功能 （因为穷没钱买其他安卓表） 。 设备参数型号: 小天才XTC Z1S 手表版本: 2.4.5 安卓版本: 4.4.4 开启ADB 首先在该版本下，在设置中连续点击10次“安卓版本”是不会出现开发者模式的，我们要开启ADB只能另寻途径 小天才官方预留了ADB打开的选项，我们只需来到拨号界面，输入*#0769651#* 即进入配置界面 然后将“打开ADB”勾选上即可","link":"/2020/12/27/%E5%B0%8F%E5%A4%A9%E6%89%8DXTC%20Z1S%E5%BC%80%E5%90%AFADB/"},{"title":"数列及其不动点（文件）","text":"数列题目:OneDrive 百度网盘w45h不动点求法PPT：OneDrive 百度网盘o8gm OneDrive打不开请修改hosts文件","link":"/2020/03/03/%E6%95%B0%E5%88%97%E5%8F%8A%E5%85%B6%E4%B8%8D%E5%8A%A8%E7%82%B9%EF%BC%88%E6%96%87%E4%BB%B6%EF%BC%89/"},{"title":"搭建Hexo博客","text":"注意事项 对于 macOS 和 Linux用户如果权限报错请在命令前添加sudo 安装Nodejs 访问官网https://nodejs.org 我们可以看到有“LTS”(长期支持版)和“Current”(当前发布版) LTS比较稳定，Current包含最新特性，这里我们选择LTS版本 下载后安装后，打开命令行分别输入下方命令，出现版本号即成功 12node -vnpm -v 安装hexo使用cnpm国内因为网络问题npm安装较慢，所以我们改用淘宝源的cnpm 1npm install -g cnpm --registry=https://registry.npm.taobao.org 然后 1cnpm -v 出现版本号 hexo安装输入命令 1cnpm install -g hexo-cli 出现warning提示忽略就行 hexo初始化创建你博客的文件夹，利用命令行进入该目录输入以下命令 1hexo init 安装git部署插件此插件用于部署到远端 1cnpm install --save hexp-deployer-git 本地启动1hexo s 从浏览器输入localhost:4000就能看到预览 创建文章1hexo n &quot;你的文章名字&quot; 生成文件在 你创建的文件夹/source/_posts 里 使用markdown编辑器编辑文章即可（此处你需要掌握markdown语法） 部署到GitHub创建GitHub Page 登陆GitHub 点击右上角+,创建仓库 仓库名(Repository name)格式必须为 你的github昵称.github.io 点击“创建仓库”（Create repository） 配置文件编辑你创建的文件夹下的 _config.yml 文件 填写github仓库地址 内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#此处填写你的博客标题title: subtitle: ''description: ''keywords: null#博客作者author: #页面语言language: zh-CNtimezone: ''#博客的urlurl: root: /permalink: ':year/:month/:day/:title/'permalink_defaults: nullpretty_urls: trailing_index: true trailing_html: truesource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: ':lang'skip_render: nullnew_post_name: ':title.md'default_layout: posttitlecase: falseexternal_link: enable: true field: site exclude: ''filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: '' wrap: true hljs: falseprismjs: enable: false preprocess: true line_number: true tab_replace: ''index_generator: path: '' per_page: 10 order_by: '-date'default_category: uncategorizedcategory_map: nulltag_map: nullmeta_generator: truedate_format: YYYY-MM-DDtime_format: HH:mm:ssupdated_option: mtimeper_page: 10pagination_dir: pageinclude: nullexclude: nullignore: null#博客的主题，注意名称要与themes文件夹下主题文件夹名称一致theme: icarus#提交仓库deploy: - type: git #此处填写仓库地址 repo: #仓库分支 branch: master 推送到GitHub1hexo d 注意：在这个过程中会要求输入GitHub的账号和密码 域名配置1.服务商设置在你的服务商购买域名，并CNAME解析到GitHub上 2.本地source目录配置在source目录下创建名称为CNAME的文件内容填写你的域名（不要加http或https） 然后再次提交 1hexo d","link":"/2021/06/16/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/"},{"title":"最简单的方式搭建typecho博客","text":"购买并配置服务器 购买域名并选择阿里云的轻量应用服务器的PT-Panel(宝塔Linux面板)镜像,如图 购买并安装完成后，在阿里云控制台中找到服务器并选择第二个按钮，然后 详情-&gt;应用管理-&gt;应用详情 按照其提示进入远程命令行，复制粘贴命令并执行得到面板密码 浏览器访问http://服务器外网IP:8888(注意:要在防火墙页面开启8888端，在防火墙页面添加规则，端口范围填8888并保存即可) 输入账号(默认admin)和你刚才获取的密码,就能够登陆进去了 如果提示，选择安装LAMP环境(即:Apache+MySQL+PHP,L指Linux也就是服务器目前的系统)，如果不提示则在面板的软件商店里单独安装 安装 在宝塔面板中找到 网站-&gt;添加站点，填写你的域名，数据库选择MySQL，数据库用户名和密码(用户名推荐typecho)，其余默认 在你的PC上去typecho官网下载，这里推荐下载正式版防止不稳定 回到宝塔面板-&gt;网站-&gt;点击你的域名 点击上传-&gt;选择文件（找到你刚才下好的压缩包)-&gt;开始上传-&gt;上传完成后点击下面的关闭 解压与设置 解压压缩包-&gt;得到build文件夹-&gt;进入build-&gt;全部选中点击剪贴-&gt;返回上一级目录-&gt;粘贴 重启服务器(这里推荐重启服务器而不是重启服务) 浏览器访问你的域名，我们就可以看到typecho的安装界面了 填写：数据库用户名和数据库密码(你在”安装”这一小节第一步所填写的)，网站登录用户名和密码,其余默认(不懂不要乱填)，然后点击“确认，开始安装”按钮就可以了 (注意:数据库名称与你的数据库用户名一致) 提示：你的博客地址： http://域名 你的登录界面: http://域名/admin 相关问题 . 如果你想知道为什么不用Wordpress搭建博客的话，那是因为Wordpress会有一些问题并且最近其官网无法访问 你同样也可以选择搭建LNMP环境,二者基本步骤没有太大差异,这里不过多描述 插件和主题文件夹分别在 刚才配置的目录/usr/plugins 和 刚才配置的目录/usr/themes (这里是指网站的usr不是系统的) 插件下载解压后会获得一个文件夹，通过宝塔面板将整个文件夹(是这个进去有Plugin.php文件的这个文件夹而不是里面的文件）通过宝塔面板上传到上述plugins目录下，并且重命名这个文件夹与插件名称一致，否则启动插件会提示”server error” 关于插件与主题的下载在下方的推荐里有 推荐 官方插件网站：点击这里 主题模板站：点击这里 我使用的插件： 动态看版娘 pio GitHub 作者：奇趣保罗 圣诞节页面下雪 Snow GitHub 作者博客…… 插件使用了很多，我实在是懒得写了，自己感兴趣的话就去官方插件网站和官方网站及其社区看看","link":"/2020/03/05/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAtypecho%E5%8D%9A%E5%AE%A2/"},{"title":"树莓派SMB网络存储服务器","text":"安装 命令行输入 1sudo apt-get install samba 设置 设置密码(用户名必须是你系统用户)sudo smbpasswd -a 用户名 会让你两次输入密码，有如下提示 123New SMB password:Retype new SMB password:Added user for 这里会显示你的用户名 执行sudo vi /etc/samba/smb.conf Authentication段找到#security = user并去掉”#” 文件尾部添加如下内容 123456789#等号后填写你所共享的目录path = comment = NAS Drive#写入权限wirteable = yesbrowseable = yes#创建文件权限create mask = 0777public = yes reboot重启 推荐[post cid=”23” cover=”https://cairbin.top/pic/raspi.png&quot;/]","link":"/2020/03/10/%E6%A0%91%E8%8E%93%E6%B4%BESMB%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"栈的概念及性质","text":"栈的基本概念栈的定义 栈是一种只能在一端进行插入或删除的线性表。其中插入被称作进栈，删除被称作出栈。 允许进行插入或删除操作的一端被称为栈顶，另一段被称为栈底，栈底固定不变。其中，栈顶由一个称为栈顶指针的位置指示器来指示。 （PS：栈顶指针并非传统意义上的指针，比如顺序栈用的是一个整型变量来指示，但是我们依然称其为栈顶指针） 栈的特点 先进后出 栈的数学结构当n个元素以某种顺序进栈，并且在满足先进后出的前提下可任意时刻出栈，所获得的元素排列数目满足函数 Catalan( )的计算，即： 当然你也可以得到化简形式 栈的储存结构 顺序栈 链栈 （PS：栈是一种稍加限制的线性表，因此顺序栈与链栈就类似于顺序表和链表）","link":"/2021/09/28/%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89/"},{"title":"树莓派Ubuntu18.04(arm64)解决armhf安装问题","text":"报错arm64的Ubuntu直接安装armhf软件的话会有以下报错: 解决 在命令行输入： 123sudo dpkg --add-architecture armhfsudo apt-get updatesudo apt-get upgrade 再次尝试安装 sudo dpkg -i 目录或安装包名 如果还是报错,尝试执行以下命令再重新上述安装 12apt-get install -fapt-get install libxtst6:armhf","link":"/2020/03/09/%E6%A0%91%E8%8E%93%E6%B4%BEUbuntu18.04(arm64)%E8%A7%A3%E5%86%B3armhf%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/"},{"title":"树莓派安装花生壳","text":"问题与报错 花生壳目前需要实名认证,如果您不想这样麻烦的话,请另寻其他方法 如果你的系统为arm64(例如Ubuntu18.04)，那么你可能会遇到如下问题 可以参考我另外一篇文章,来解决此问题才能继续安装 [post cid=”20” cover=”https://cair.rinue.top/pic/raspi.png&quot;/] 安装您有两种选择： 进入花生壳官网下载最新版,然后利用*WinSCP(SSH服务)*等软件上传 在树莓派上使用wget命令直接获取[可能需要您安装wget(后边命令是基于Debian的系统):sudo apt-get install wget] 本文采取2方法 执行命令(如果失败请查看本文开头所提到的问题是否解决) 12sudo wget http://download.oray.com/peanuthull/embed/phddns_3.0.4_systemd.debsudo dpkg -i phddns_3.0.4_systemd.deb 安装成功会显示SN码、默认密码以及远程管理地址 配置 浏览器输入远程管理地址b.oray.com 输入安装花生壳时生成的SN码和默认密码admin 进去后会让你微信扫描或手机验证码激活，激活后会免费获得一个域名 默认内置帐号只有公网版服务，如需使用内网穿透功能，要自行开通 开通后要实名认证，然后你就可以通过域名来访问树莓派了 如果有花生壳账号，也可以使用自己的账号,点击切换账号然后登陆(如果你绑定了微信,之前扫码激活时会提示你分配到花生壳账号，不过不影响后续操作) 命令 如果以下命令缺少权限报错可以在前面加上 sudo 启动花生壳systemctl start phddns 停止systemctl stop phddns 重启systemctl restart phddns 状态systemctl status phddns 版本systemctl version phddns 重置systemctl reset phddns 其他 本文参考了官方教程，相关安装图片也来自官方教程","link":"/2020/03/12/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85%E8%8A%B1%E7%94%9F%E5%A3%B3/"},{"title":"树莓派Ubuntu命令行连接Wifi","text":"说明我的设备是树莓派3B+,系统是官方提供的Ubuntu18.04 64位,其他型号应该也适用此方法如果你的系统未安装wireless-tools和wpasupplicant请使用以下命令安装 12sudo apt-get install wireless-toolssudo apt-get install wpasupplicant 开始 利用Vim打开/etc/network/interfaces 命令如下sudo vi /etc/network/interfaces 添加如下内容: 123456auto wlan0 iface wlan0 inet dhcp#下方引号填写你的Wifi名称wpa-ssid &quot;&quot;#下方引号填写你的密码wpa-psk &quot;&quot; 提示 如果有条件尽量还是用网线，毕竟能省不少事 关于树莓派安装Ubuntu请见以下文章[post cid=”16” /]","link":"/2020/03/09/%E6%A0%91%E8%8E%93%E6%B4%BEUbuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9E%E6%8E%A5Wifi/"},{"title":"解决hexo报错spwan failed","text":"报错112345678910FATAL { err: Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (/usr/local/src/hexo/cairbin/node_modules/hexo-util/lib/spawn.js:51:21) at ChildProcess.emit (events.js:376:20) at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) { code: 128 }} Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html 解决方案 进行以下处理 12345678##进入博客根目录(以我的为例)cd /usr/local/src/hexo/cairbin/##删除git提交文件夹rm -rf .deploy_git/git config --global core.autocrlf false 最后重新生成提交 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 在提交的过程可能又出现以下报错 报错21! [remote rejected] master -&gt; master (push declined due to email privacy restrictions) 解决方案 这是因为你的github设置出了问题 浏览器进入github.com 登陆github -&gt; “+” -&gt;settings 后续操作如下图 将下方这两个设置取消勾选 重新提交 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 大功告成如果不报错，重新访问页面，就发现已经提交成功了","link":"/2021/07/01/%E8%A7%A3%E5%86%B3hexo%E6%8A%A5%E9%94%99spwan%20failed/"},{"title":"链表的定义","text":"链表链表的概念定义：链表是一种物理存储单元上非连续、非顺序的存储结构，由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。 在链表的储存上，每个结点不仅包含所存的元素信息，还包含元素间的逻辑信息。 链表的特性 不支持随机访问：不能通过知道第一个元素的地址（即储存空间的首地址）可以轻松访问储存的所有数据。 节点的储存空间利用率相对顺序表较低：链表中的每分一个结点需要划出一部分空间来储存指向下一个结点位置的指针 支持储存空间的动态分配：链表中当前结点的位置是由其前驱结点中的地址信息所指示的。其结点可以散落在内存中的任意位置，且不需要一次性地划分所有结点所需的空间给它。 在链表中进行插入操作无需移动元素（而顺序表需要） 链表的形式单链表在每个结点除了包含的数据域外，还包含一个指针域，用以指向其后继结点。 带头结点的单链表 带头结点的单链表中，头指针head指向头结点，头结点的值域不含任何信息，从头结点的后继结点开始储存信息。头指针head 始终不等于NULL，head-&gt;next等于NULL的时候，链表为空。 不带头结点的单链表 不带头结点的单链表中的头指针head直接指向开始结点，当head等于NULL时，链表为空。 双链表双链表就是在单链表结点上增添了一个指针域，指向当前节点的前驱。 相比于单链表，双链表能够从终端结点反向走到开始结点。 循环链表 循环单链表 只需要将单链表最后一个指针域（空指针）指向链表中的第一个结点即可。（如果循环单链表带头结点，则指向头结点；不带头结点，则指向开始结点）。 循环单链表可以实现从任何一个结点出发，访问链表中任何结点。（注意：此处应该区分与顺序表随机访问的特点。循环单链表指的是从一个结点出发，而不是知道一个结点从而迅速找到任何一个结点，因此循环单链表不具有随机访问特性。） 带头结点的循环单链表，当head等于head-&gt;next时，链表为空；不带头结点的循环单链表，当head等于NULL时，链表为空。 循环双链表 双链表终端节点的next指针指向链表中第一个结点，将链表中的第一个结点的prior指针指向终端结点。 不带头结点的循环双链表，head等于NULL，链表为空 带头结点的循环双链表是没有空指针的，其为空状态下，head-&gt;next与head-&gt;prior必然都等于head，故一下四种语句都可判断为空 1234head-&gt;next == head;head-&gt;prior == head;head-&gt;next == head &amp;&amp; head-&gt;prior == head;head-&gt;next == head || head-&gt;prior == head; 静态链表静态链表借助一维数组表示。 静态链表结点空间来自于一个结构体数组（一般链表结点空间来自整个内存），数组中每个结点含两个分量： 数据元素分量data 指针分量（指示了当前结点直接后继节点在数组中的位置） 注意：静态链表的指针不是通常所说储存内存地址的指针型变量，而是储存数组下标的整型变量，其功能类似于指针，故在此称为指针 顺序表与链表区别基于空间比较 储存的分配方式 顺序表储存空间时一次性分配的，链表的是多次分配的 存储密度 （注： 存储密度 = 结点值域所占存储量/结点结构所占存储总量） 顺序表存储密度 = 1 链表存储密度 &lt; 1 基于时间的比较 存取方式 顺序表可以随机存取，也可以顺序存取 链表只能顺序存取 插入/删除时移动元素个数 顺序表平均需要移动一半元素 链表不需要移动元素，仅需修改指针","link":"/2021/08/19/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89/"},{"title":"解决Handsome7.2主题 CodePrettify插件 代码高亮显示不正常的问题","text":"前提我是用的CodePrettify插件实现的Mac样式代码高亮，详情可访问以下链接。 遇到此问题时，请您先检查您是否已经按照下方链接中的说明进行了正确操作(即先判断是否因您之前操作失误所导致代码高亮显示不正常)，然后才可以开始按照本文下方步骤解决对应问题！！！！ 作者：Xcnte' s Blog网址：https://www.xcnte.com/archives/523/ 解决问题 进入typecho后台 找到 插件 进入 Handsome 插件的设置 “编辑器设置”一栏中的“前台Markdown解析方式选择”，勾选为“使用typecho自带的markdown解析器” 保存 然后回到文章页面刷新或清除浏览器缓存即可发现高亮已经恢复","link":"/2020/08/11/%E8%A7%A3%E5%86%B3Handsome7.2%E4%B8%BB%E9%A2%98-CodePrettify%E6%8F%92%E4%BB%B6-%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E6%98%BE%E7%A4%BA%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"直接插入排序","text":"本文为了方便理解，先上代码再做解释 插入排序代码12345678910111213141516void InsertSort(int R[], int n){ int i,j, temp; for(i = 1; i&lt;n; i++) { temp = R[i]; j = i-1; while(j &gt;= 0 &amp;&amp; temp &lt; R[j]) { R[j+1] = R[j]; j--; } R[j+1] = temp; }} 解释算法思想每趟将一个待排序的关键字按其值的大小插入到已经排好的部分有序序列的适当位置上，直到所有的待派关键字都被插入到有序序列中 举例有一原始序列: {49, 38, 65, 97, 76, 13, 27, 49} 一开始看49，一个数显然有序 49 38 65 97 76 13 27 49 插入38。38 &lt; 49 ，所以49向后移动一个位置，38插入到49原来位置 49 38 65 97 76 13 27 49 插入65。65 &gt; 49，所以不需要移动，65应该在就应该在49后 38 49 65 97 76 13 27 49 插入97。 97 &gt; 65，所以不需要移动，97就应该在65之后 38 49 65 97 76 13 27 49 插入76。76 &lt; 97,所以97向后移动一个位置;继续比较，76 &gt; 65，65不需要移动，76应该插入65之后、97之前 38 49 65 76 97 13 27 49 …… 最后插入49，从后向前比较，直到49 = 49 &lt; 65，位置确定，49应该插在49之后65之前 13 27 38 49 49 65 76 97","link":"/2021/10/13/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"title":"顺序栈的操作","text":"栈的定义123456789101112#include &lt;iostream&gt;#define MAXSIZE 1000using namespace std;//顺序栈typedef struct{ int data[MAXSIZE]; //存放栈顶元素 int top; //栈顶指针}SqStack; 栈的操作初始化123456//初始化顺序栈bool initStack(SqStack &amp;st){ st.top = -1; return true;} 判断为空12345678//判断栈是否为空bool isEmpty(SqStack st){ if(st.top == -1) return true; else return false;} 入栈123456789bool pushStack(SqStack &amp;st, int e){ if(st.top == MAXSIZE - 1) return false; //栈已满，再入栈会上溢 //对于入栈，一定要先改指针再入 st.top++; st.data[st.top] = e; return true;} 出栈1234567891011bool popStack(SqStack &amp;st, int &amp;e){ if(st.top == -1) return false; //栈空不能继续出栈，否则下溢 //对于出栈，先出元素再取指针 e = st.data[st.top]; st.top--; return true;} 获取栈顶元素12345678//获取栈顶元素bool getStackTopElem(SqStack st, int &amp;e){ if(st.top == -1) return false; //栈空，无元素返回 e = st.data[st.top]; return true;}","link":"/2021/10/07/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"title":"顺序表应用——逆置问题","text":"顺序表应用——逆置问题问题描述给定一个顺序表，将其中的元素逆置 例子给定一个顺序表，其中有0至10共11个元素从小至大排列，请将这11个元素逆置使其从大到小排列 以下是解题代码 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#define MAXSIZE 100typedef struct{ int data[MAXSIZE]; int length;}Sqlist;//输出元素void printList(Sqlist L){ for(int n = 0; n &lt;= 10; n++) { std::cout &lt;&lt; L.data[n] &lt;&lt; std::endl; }}//置换void swapList(Sqlist &amp;L){ for(int j = 0, k = 10; j &lt; k; j++, k--) { int temp = L.data[j]; //临时变量用于临时存放j位置数据 L.data[j] = L.data[k];//将k位置的保存到j位置 L.data[k] = temp; //将k位置的替换为原j位置的值 } }int main(){ Sqlist L; //线性表初始化 L.length = 0; //插入元素 for(int i = 0; i &lt;= 10;i++) { L.data[i] = i; L.length++; } //输出置换前的顺序表内容用于对比 std::cout &lt;&lt; &quot;置换前的数据：&quot;&lt;&lt; std::endl; printList(L); //置换 swapList(L); //输出置换后的内容 std::cout &lt;&lt; &quot;置换后的数据：&quot; &lt;&lt; std::endl; printList(L); system(&quot;pause&quot;); return 0; } 输出结果123456789101112131415161718192021222324置换前的数据：012345678910置换后的数据：109876543210","link":"/2021/09/25/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E9%80%86%E7%BD%AE%E9%97%AE%E9%A2%98/"},{"title":"顺序表的操作","text":"顺序表的操作这里先定义个顺序表 12345678910111213#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100typedef struct{ int *elems; int length; int size;}Sqlist;Sqlist list; 顺序表初始化 定义bool类型函数 initList() ，初始化成功为true，失败为false 1234567891011//初始化顺序表，创建一个空表bool initList(Sqlist &amp;L) //L本身要改变所以为引用型{ L.elems = new int[MAXSIZE]; //为顺序表分配内存空间 if(!L.elems) return false; //存储分配失败返回false //分配成功则初始化 L.length = 0; L.size = MAXSIZE; return true; //成功并返回true} 定义函数 outputInfoList() 用于输出顺序表信息 123456789//输出数据表信息void outputInfoList(Sqlist &amp;L){ cout &lt;&lt; &quot;顺序表储存空间&quot; &lt;&lt; L.size &lt;&lt; &quot;,已经保存元素个数&quot; &lt;&lt; L.length &lt;&lt; endl; for(int i = 0; i &lt;= L.length - 1;i++){ cout &lt;&lt; L.elems[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl;} 找查元素 定义函数 findElem() 在顺序表中找查一个等于e的元素 1234567891011121314/** 用于找查顺序表中的元素* 参数e为要找查的元素* 若找到则返回元素下标* 若没找到则返回-1*/int findElem(Sqlist L, int e) //这里我们不改变L，所以不用引用类型{ for(int i = 0; i &lt; L.length; i++){ if(e == L.elems[i]) return i; //若找到则返回元素下标 } return -1; //若没找到则返回-1} 插入元素尾部添加元素在尾部添加元素要考虑以下几点 顺序表是否已满 添加成功后长度要加1 故定义函数 listAppend() 123456789101112131415/** 在顺序表尾部插入元素* 参数e为要插入到尾部的元素* 若成功则返回true，失败（顺序表已经满了）则返回false*/bool listAppend(Sqlist &amp;L, int e){ if(L.length == L.size) //顺序表满了 return false; //没满则尾部插入元素并返回true L.elems[L.length] = e; L.length++; return true;} 在特定位置插入元素在特定位置插入要考虑以下几点 顺序表是否已满 添加成功后长度要加1 要移动后面的元素而不能移动前面的元素，否则后面的元素会被前面的覆盖 定义如下 123456789101112131415161718//在顺序表p位置（0 &lt;= p &lt;= length）上插入元素ebool insertElem(Sqlist &amp;L, int p, int e){ if(p &lt; 0 || p &gt; L.length || L.length == MAXSIZE) /* * 如果位置错误 * 或者表长已经达到最大允许值 * 此时插入不成功并返回false */ return false; for(int i = L.length - 1; i &gt;= p; --i) //从后往前将元素相后方移动一个位置 L.elems[i+1] = L.elems[i]; L.elems[p] = e; //插入元素e到p位置 L.length++; return true; //成功返回true } 删除元素删除元素要考虑以下几点 顺序表位置是否正确 成功后长度要减去1 后方元素向前移动一个位置 12345678910111213141516//删除p位置的元素bool delElem(Sqlist &amp;L, int p, int &amp;e){ //位置错误返回false if(p &lt; 0 || p &gt; L.length - 1) return false; e = L.elems[p]; //将被删除的元素赋值给e for(int i = p; i &lt; L.length - 1; i++) { //从p开始后方元素向前移动一个位置 L.elems[i] = L.elems[i+1]; } L.length--; //长度减去1 return true; //成功返回true } 顺序表的销毁 在初始化函数中，用了new来分配内存，所以在销毁时要释放内存 1234567void destroy(Sqlist &amp;L){ //内存存在则释放内存 if(L.elems) delete []L.elems; L.length = 0; L.size = 0;}","link":"/2021/08/09/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"title":"链栈的操作","text":"链栈的定义123456789#include &lt;iostream&gt;using namespace std;//链栈,理论上只要内存够大不存在上溢，只存在下溢（栈空后继续取出元素）typedef struct _QNode{ int data; struct _QNode *next;}StNode; 链栈的操作初始化1234567bool initStack(StNode* &amp;st){ st = new StNode; if(!st) return false; st-&gt;next = NULL; return true;} 判断栈空1234567bool isEmpty(StNode *st){ if(st-&gt;next == NULL) return true; else return false;} 入栈12345678910111213bool pushStack(StNode* &amp;st, int e){ StNode *node = new StNode; if(!node) return false; node-&gt;data = e; node-&gt;next = st-&gt;next; st-&gt;next = node; return true;} 出栈123456789101112bool popStack(StNode* &amp;st, int &amp;e){ if(!(st-&gt;next)) return false; //栈空 StNode *p; p = st-&gt;next; e = p-&gt;data; st-&gt;next = p-&gt;next; delete p; return true; }","link":"/2021/10/10/%E9%93%BE%E6%A0%88%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"title":"顺序表的概念及定义","text":"顺序表结点的概念结点 ：结点是内存中一片由用户分配的储存空间，只有一个地址来表示它的存在，没有显式名称。 在学习顺序表时，一般不会去特别强调结点的概念，此概念往往在链表学习中涉及，但并不代表结点与顺序表无关，所以我特意把结点的概念放在此处以加深对顺序表的理解。 顺序表的概念定义：把逻辑上相邻的结点储存在物理位置上的相邻储存单元中，结点的逻辑关系由储存单元的邻接关系来体现 通俗来讲，顺序表就是把线性表中的所有元素按照其逻辑顺序，依次储存到从指定的储存位置开始的一块连续的储存空间中。 第一个元素的储存位置就是指定的储存位置，第 i+1 个元素的储存位置在第 i 个元素后面 顺序表的特性 占用连续的储存空间：由定义可知顺序表的储存空间必然连续，并且存储分配只能预先进行，一旦分配完毕，在操作过程中始终不变。 随机访问特性：因为储存空间是连续的，知道第一个元素的地址（即储存空间的首地址）可以轻松访问储存的所有数据。每一个结点对应一个序号，由该序号可以直接算出结点的储存地址。 顺序表三要素 顺序表基地址 顺序表长度 顺序表总空间大小 顺序表结构体定义123456typedef struct _Sqlist Sqlist;struct _Sqlist { int *elems; //顺序表基地址 int length; //顺序表长度 int size; //顺序表总空间大小}; 当然C语言提供了一种简单的写法（如下,以后以简单写法为例）。 123456typedef struct{ int *elems; //顺序表基地址 int length; //顺序表长度 int size; //顺序表总空间大小 }Sqlist; 在某些书籍上，有这样定义顺序表的 1#define MAXSIZE 100 1234typedef struct { int data[MAXSIZE]; //存放顺序表元素的数组 int length; //存放顺序表的长度}Sqlist; 实际上这种定义已经为顺序表开辟了一部分内存空间，而前者需要使用函数来顺序表初始化。 但实际上两种代码本质上是一样的，因为前者在顺序表的操作——初始化顺序表中的函数定义中，我们仍需要分配一片储存空间并且定义一个存放顺序表元素的数组；而后者相当于把这一步合并到了定义中。 在学习过程而非实际开发中，我更倾向于前者，因为这更能反应顺序表的三要素，并且与链表代码书写风格相似，有利于感受线性表思想的共性。 结束我们现在已经成功定义顺序表了，但更重要的是它的操作，所以下一篇文章就来写这部分内容。","link":"/2021/08/09/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9A%E4%B9%89/"}],"tags":[{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/tags/C-C/"},{"name":"指针","slug":"指针","link":"/tags/%E6%8C%87%E9%92%88/"},{"name":"五子棋","slug":"五子棋","link":"/tags/%E4%BA%94%E5%AD%90%E6%A3%8B/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"BadApple","slug":"BadApple","link":"/tags/BadApple/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"结构体","slug":"结构体","link":"/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"MicroBit","slug":"MicroBit","link":"/tags/MicroBit/"},{"name":"智能小车","slug":"智能小车","link":"/tags/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/"},{"name":"CuteBot","slug":"CuteBot","link":"/tags/CuteBot/"},{"name":"Log","slug":"Log","link":"/tags/Log/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Minecraft","slug":"Minecraft","link":"/tags/Minecraft/"},{"name":"MC","slug":"MC","link":"/tags/MC/"},{"name":"我的世界","slug":"我的世界","link":"/tags/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C/"},{"name":"arm","slug":"arm","link":"/tags/arm/"},{"name":"Lumia","slug":"Lumia","link":"/tags/Lumia/"},{"name":"NOKIA","slug":"NOKIA","link":"/tags/NOKIA/"},{"name":"Qt","slug":"Qt","link":"/tags/Qt/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"环境变量","slug":"环境变量","link":"/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"name":"VS","slug":"VS","link":"/tags/VS/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Hackintosh","slug":"Hackintosh","link":"/tags/Hackintosh/"},{"name":"Experiment","slug":"Experiment","link":"/tags/Experiment/"},{"name":"小天才","slug":"小天才","link":"/tags/%E5%B0%8F%E5%A4%A9%E6%89%8D/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"RaspberryPi","slug":"RaspberryPi","link":"/tags/RaspberryPi/"}],"categories":[{"name":"HTML&#x2F;CSS","slug":"HTML-CSS","link":"/categories/HTML-CSS/"},{"name":"C#","slug":"C","link":"/categories/C/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/categories/C-C/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"MicroBit","slug":"MicroBit","link":"/categories/MicroBit/"},{"name":"Journal","slug":"Journal","link":"/categories/Journal/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Minecraft","slug":"Minecraft","link":"/categories/Minecraft/"},{"name":"Blog","slug":"Blog","link":"/categories/Blog/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Mac","slug":"Mac","link":"/categories/Mac/"},{"name":"Chemistry","slug":"Chemistry","link":"/categories/Chemistry/"},{"name":"Math","slug":"Math","link":"/categories/Math/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"}]}